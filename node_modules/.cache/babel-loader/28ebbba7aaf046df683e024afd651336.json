{"ast":null,"code":"import { toUint8, bytesToNumber, bytesMatch, bytesToString, numberToBytes, padStart } from './byte-helpers';\nimport { getAvcCodec, getHvcCodec, getAv1Codec } from './codec-helpers.js'; // relevant specs for this parser:\n// https://matroska-org.github.io/libebml/specs.html\n// https://www.matroska.org/technical/elements.html\n// https://www.webmproject.org/docs/container/\n\nexport var EBML_TAGS = {\n  EBML: toUint8([0x1A, 0x45, 0xDF, 0xA3]),\n  DocType: toUint8([0x42, 0x82]),\n  Segment: toUint8([0x18, 0x53, 0x80, 0x67]),\n  SegmentInfo: toUint8([0x15, 0x49, 0xA9, 0x66]),\n  Tracks: toUint8([0x16, 0x54, 0xAE, 0x6B]),\n  Track: toUint8([0xAE]),\n  TrackNumber: toUint8([0xd7]),\n  DefaultDuration: toUint8([0x23, 0xe3, 0x83]),\n  TrackEntry: toUint8([0xAE]),\n  TrackType: toUint8([0x83]),\n  FlagDefault: toUint8([0x88]),\n  CodecID: toUint8([0x86]),\n  CodecPrivate: toUint8([0x63, 0xA2]),\n  VideoTrack: toUint8([0xe0]),\n  AudioTrack: toUint8([0xe1]),\n  // Not used yet, but will be used for live webm/mkv\n  // see https://www.matroska.org/technical/basics.html#block-structure\n  // see https://www.matroska.org/technical/basics.html#simpleblock-structure\n  Cluster: toUint8([0x1F, 0x43, 0xB6, 0x75]),\n  Timestamp: toUint8([0xE7]),\n  TimestampScale: toUint8([0x2A, 0xD7, 0xB1]),\n  BlockGroup: toUint8([0xA0]),\n  BlockDuration: toUint8([0x9B]),\n  Block: toUint8([0xA1]),\n  SimpleBlock: toUint8([0xA3])\n};\n/**\n * This is a simple table to determine the length\n * of things in ebml. The length is one based (starts at 1,\n * rather than zero) and for every zero bit before a one bit\n * we add one to length. We also need this table because in some\n * case we have to xor all the length bits from another value.\n */\n\nvar LENGTH_TABLE = [128, 64, 32, 16, 8, 4, 2, 1];\n\nvar getLength = function getLength(byte) {\n  var len = 1;\n\n  for (var i = 0; i < LENGTH_TABLE.length; i++) {\n    if (byte & LENGTH_TABLE[i]) {\n      break;\n    }\n\n    len++;\n  }\n\n  return len;\n}; // length in ebml is stored in the first 4 to 8 bits\n// of the first byte. 4 for the id length and 8 for the\n// data size length. Length is measured by converting the number to binary\n// then 1 + the number of zeros before a 1 is encountered starting\n// from the left.\n\n\nvar getvint = function getvint(bytes, offset, removeLength, signed) {\n  if (removeLength === void 0) {\n    removeLength = true;\n  }\n\n  if (signed === void 0) {\n    signed = false;\n  }\n\n  var length = getLength(bytes[offset]);\n  var valueBytes = bytes.subarray(offset, offset + length); // NOTE that we do **not** subarray here because we need to copy these bytes\n  // as they will be modified below to remove the dataSizeLen bits and we do not\n  // want to modify the original data. normally we could just call slice on\n  // uint8array but ie 11 does not support that...\n\n  if (removeLength) {\n    valueBytes = Array.prototype.slice.call(bytes, offset, offset + length);\n    valueBytes[0] ^= LENGTH_TABLE[length - 1];\n  }\n\n  return {\n    length: length,\n    value: bytesToNumber(valueBytes, {\n      signed: signed\n    }),\n    bytes: valueBytes\n  };\n};\n\nvar normalizePath = function normalizePath(path) {\n  if (typeof path === 'string') {\n    return path.match(/.{1,2}/g).map(function (p) {\n      return normalizePath(p);\n    });\n  }\n\n  if (typeof path === 'number') {\n    return numberToBytes(path);\n  }\n\n  return path;\n};\n\nvar normalizePaths = function normalizePaths(paths) {\n  if (!Array.isArray(paths)) {\n    return [normalizePath(paths)];\n  }\n\n  return paths.map(function (p) {\n    return normalizePath(p);\n  });\n};\n\nvar getInfinityDataSize = function getInfinityDataSize(id, bytes, offset) {\n  if (offset >= bytes.length) {\n    return bytes.length;\n  }\n\n  var innerid = getvint(bytes, offset, false);\n\n  if (bytesMatch(id.bytes, innerid.bytes)) {\n    return offset;\n  }\n\n  var dataHeader = getvint(bytes, offset + innerid.length);\n  return getInfinityDataSize(id, bytes, offset + dataHeader.length + dataHeader.value + innerid.length);\n};\n/**\n * Notes on the EBLM format.\n *\n * EBLM uses \"vints\" tags. Every vint tag contains\n * two parts\n *\n * 1. The length from the first byte. You get this by\n *    converting the byte to binary and counting the zeros\n *    before a 1. Then you add 1 to that. Examples\n *    00011111 = length 4 because there are 3 zeros before a 1.\n *    00100000 = length 3 because there are 2 zeros before a 1.\n *    00000011 = length 7 because there are 6 zeros before a 1.\n *\n * 2. The bits used for length are removed from the first byte\n *    Then all the bytes are merged into a value. NOTE: this\n *    is not the case for id ebml tags as there id includes\n *    length bits.\n *\n */\n\n\nexport var findEbml = function findEbml(bytes, paths) {\n  paths = normalizePaths(paths);\n  bytes = toUint8(bytes);\n  var results = [];\n\n  if (!paths.length) {\n    return results;\n  }\n\n  var i = 0;\n\n  while (i < bytes.length) {\n    var id = getvint(bytes, i, false);\n    var dataHeader = getvint(bytes, i + id.length);\n    var dataStart = i + id.length + dataHeader.length; // dataSize is unknown or this is a live stream\n\n    if (dataHeader.value === 0x7f) {\n      dataHeader.value = getInfinityDataSize(id, bytes, dataStart);\n\n      if (dataHeader.value !== bytes.length) {\n        dataHeader.value -= dataStart;\n      }\n    }\n\n    var dataEnd = dataStart + dataHeader.value > bytes.length ? bytes.length : dataStart + dataHeader.value;\n    var data = bytes.subarray(dataStart, dataEnd);\n\n    if (bytesMatch(paths[0], id.bytes)) {\n      if (paths.length === 1) {\n        // this is the end of the paths and we've found the tag we were\n        // looking for\n        results.push(data);\n      } else {\n        // recursively search for the next tag inside of the data\n        // of this one\n        results = results.concat(findEbml(data, paths.slice(1)));\n      }\n    }\n\n    var totalLength = id.length + dataHeader.length + data.length; // move past this tag entirely, we are not looking for it\n\n    i += totalLength;\n  }\n\n  return results;\n}; // see https://www.matroska.org/technical/basics.html#block-structure\n\nexport var decodeBlock = function decodeBlock(block, type, timestampScale, clusterTimestamp) {\n  var duration;\n\n  if (type === 'group') {\n    duration = findEbml(block, [EBML_TAGS.BlockDuration])[0];\n\n    if (duration) {\n      duration = bytesToNumber(duration);\n      duration = 1 / timestampScale * duration * timestampScale / 1000;\n    }\n\n    block = findEbml(block, [EBML_TAGS.Block])[0];\n    type = 'block'; // treat data as a block after this point\n  }\n\n  var dv = new DataView(block.buffer, block.byteOffset, block.byteLength);\n  var trackNumber = getvint(block, 0);\n  var timestamp = dv.getInt16(trackNumber.length, false);\n  var flags = block[trackNumber.length + 2];\n  var data = block.subarray(trackNumber.length + 3); // pts/dts in seconds\n\n  var ptsdts = 1 / timestampScale * (clusterTimestamp + timestamp) * timestampScale / 1000; // return the frame\n\n  var parsed = {\n    duration: duration,\n    trackNumber: trackNumber.value,\n    keyframe: type === 'simple' && flags >> 7 === 1,\n    invisible: (flags & 0x08) >> 3 === 1,\n    lacing: (flags & 0x06) >> 1,\n    discardable: type === 'simple' && (flags & 0x01) === 1,\n    frames: [],\n    pts: ptsdts,\n    dts: ptsdts,\n    timestamp: timestamp\n  };\n\n  if (!parsed.lacing) {\n    parsed.frames.push(data);\n    return parsed;\n  }\n\n  var numberOfFrames = data[0] + 1;\n  var frameSizes = [];\n  var offset = 1; // Fixed\n\n  if (parsed.lacing === 2) {\n    var sizeOfFrame = (data.length - offset) / numberOfFrames;\n\n    for (var i = 0; i < numberOfFrames; i++) {\n      frameSizes.push(sizeOfFrame);\n    }\n  } // xiph\n\n\n  if (parsed.lacing === 1) {\n    for (var _i = 0; _i < numberOfFrames - 1; _i++) {\n      var size = 0;\n\n      do {\n        size += data[offset];\n        offset++;\n      } while (data[offset - 1] === 0xFF);\n\n      frameSizes.push(size);\n    }\n  } // ebml\n\n\n  if (parsed.lacing === 3) {\n    // first vint is unsinged\n    // after that vints are singed and\n    // based on a compounding size\n    var _size = 0;\n\n    for (var _i2 = 0; _i2 < numberOfFrames - 1; _i2++) {\n      var vint = _i2 === 0 ? getvint(data, offset) : getvint(data, offset, true, true);\n      _size += vint.value;\n      frameSizes.push(_size);\n      offset += vint.length;\n    }\n  }\n\n  frameSizes.forEach(function (size) {\n    parsed.frames.push(data.subarray(offset, offset + size));\n    offset += size;\n  });\n  return parsed;\n}; // VP9 Codec Feature Metadata (CodecPrivate)\n// https://www.webmproject.org/docs/container/\n\nvar parseVp9Private = function parseVp9Private(bytes) {\n  var i = 0;\n  var params = {};\n\n  while (i < bytes.length) {\n    var id = bytes[i] & 0x7f;\n    var len = bytes[i + 1];\n    var val = void 0;\n\n    if (len === 1) {\n      val = bytes[i + 2];\n    } else {\n      val = bytes.subarray(i + 2, i + 2 + len);\n    }\n\n    if (id === 1) {\n      params.profile = val;\n    } else if (id === 2) {\n      params.level = val;\n    } else if (id === 3) {\n      params.bitDepth = val;\n    } else if (id === 4) {\n      params.chromaSubsampling = val;\n    } else {\n      params[id] = val;\n    }\n\n    i += 2 + len;\n  }\n\n  return params;\n};\n\nexport var parseTracks = function parseTracks(bytes) {\n  bytes = toUint8(bytes);\n  var decodedTracks = [];\n  var tracks = findEbml(bytes, [EBML_TAGS.Segment, EBML_TAGS.Tracks, EBML_TAGS.Track]);\n\n  if (!tracks.length) {\n    tracks = findEbml(bytes, [EBML_TAGS.Tracks, EBML_TAGS.Track]);\n  }\n\n  if (!tracks.length) {\n    tracks = findEbml(bytes, [EBML_TAGS.Track]);\n  }\n\n  if (!tracks.length) {\n    return decodedTracks;\n  }\n\n  tracks.forEach(function (track) {\n    var trackType = findEbml(track, EBML_TAGS.TrackType)[0];\n\n    if (!trackType || !trackType.length) {\n      return;\n    } // 1 is video, 2 is audio, 17 is subtitle\n    // other values are unimportant in this context\n\n\n    if (trackType[0] === 1) {\n      trackType = 'video';\n    } else if (trackType[0] === 2) {\n      trackType = 'audio';\n    } else if (trackType[0] === 17) {\n      trackType = 'subtitle';\n    } else {\n      return;\n    } // todo parse language\n\n\n    var decodedTrack = {\n      rawCodec: bytesToString(findEbml(track, [EBML_TAGS.CodecID])[0]),\n      type: trackType,\n      codecPrivate: findEbml(track, [EBML_TAGS.CodecPrivate])[0],\n      number: bytesToNumber(findEbml(track, [EBML_TAGS.TrackNumber])[0]),\n      defaultDuration: bytesToNumber(findEbml(track, [EBML_TAGS.DefaultDuration])[0]),\n      default: findEbml(track, [EBML_TAGS.FlagDefault])[0],\n      rawData: track\n    };\n    var codec = '';\n\n    if (/V_MPEG4\\/ISO\\/AVC/.test(decodedTrack.rawCodec)) {\n      codec = \"avc1.\" + getAvcCodec(decodedTrack.codecPrivate);\n    } else if (/V_MPEGH\\/ISO\\/HEVC/.test(decodedTrack.rawCodec)) {\n      codec = \"hev1.\" + getHvcCodec(decodedTrack.codecPrivate);\n    } else if (/V_MPEG4\\/ISO\\/ASP/.test(decodedTrack.rawCodec)) {\n      if (decodedTrack.codecPrivate) {\n        codec = 'mp4v.20.' + decodedTrack.codecPrivate[4].toString();\n      } else {\n        codec = 'mp4v.20.9';\n      }\n    } else if (/^V_THEORA/.test(decodedTrack.rawCodec)) {\n      codec = 'theora';\n    } else if (/^V_VP8/.test(decodedTrack.rawCodec)) {\n      codec = 'vp8';\n    } else if (/^V_VP9/.test(decodedTrack.rawCodec)) {\n      if (decodedTrack.codecPrivate) {\n        var _parseVp9Private = parseVp9Private(decodedTrack.codecPrivate),\n            profile = _parseVp9Private.profile,\n            level = _parseVp9Private.level,\n            bitDepth = _parseVp9Private.bitDepth,\n            chromaSubsampling = _parseVp9Private.chromaSubsampling;\n\n        codec = 'vp09.';\n        codec += padStart(profile, 2, '0') + \".\";\n        codec += padStart(level, 2, '0') + \".\";\n        codec += padStart(bitDepth, 2, '0') + \".\";\n        codec += \"\" + padStart(chromaSubsampling, 2, '0'); // Video -> Colour -> Ebml name\n\n        var matrixCoefficients = findEbml(track, [0xE0, [0x55, 0xB0], [0x55, 0xB1]])[0] || [];\n        var videoFullRangeFlag = findEbml(track, [0xE0, [0x55, 0xB0], [0x55, 0xB9]])[0] || [];\n        var transferCharacteristics = findEbml(track, [0xE0, [0x55, 0xB0], [0x55, 0xBA]])[0] || [];\n        var colourPrimaries = findEbml(track, [0xE0, [0x55, 0xB0], [0x55, 0xBB]])[0] || []; // if we find any optional codec parameter specify them all.\n\n        if (matrixCoefficients.length || videoFullRangeFlag.length || transferCharacteristics.length || colourPrimaries.length) {\n          codec += \".\" + padStart(colourPrimaries[0], 2, '0');\n          codec += \".\" + padStart(transferCharacteristics[0], 2, '0');\n          codec += \".\" + padStart(matrixCoefficients[0], 2, '0');\n          codec += \".\" + padStart(videoFullRangeFlag[0], 2, '0');\n        }\n      } else {\n        codec = 'vp9';\n      }\n    } else if (/^V_AV1/.test(decodedTrack.rawCodec)) {\n      codec = \"av01.\" + getAv1Codec(decodedTrack.codecPrivate);\n    } else if (/A_ALAC/.test(decodedTrack.rawCodec)) {\n      codec = 'alac';\n    } else if (/A_MPEG\\/L2/.test(decodedTrack.rawCodec)) {\n      codec = 'mp2';\n    } else if (/A_MPEG\\/L3/.test(decodedTrack.rawCodec)) {\n      codec = 'mp3';\n    } else if (/^A_AAC/.test(decodedTrack.rawCodec)) {\n      if (decodedTrack.codecPrivate) {\n        codec = 'mp4a.40.' + (decodedTrack.codecPrivate[0] >>> 3).toString();\n      } else {\n        codec = 'mp4a.40.2';\n      }\n    } else if (/^A_AC3/.test(decodedTrack.rawCodec)) {\n      codec = 'ac-3';\n    } else if (/^A_PCM/.test(decodedTrack.rawCodec)) {\n      codec = 'pcm';\n    } else if (/^A_MS\\/ACM/.test(decodedTrack.rawCodec)) {\n      codec = 'speex';\n    } else if (/^A_EAC3/.test(decodedTrack.rawCodec)) {\n      codec = 'ec-3';\n    } else if (/^A_VORBIS/.test(decodedTrack.rawCodec)) {\n      codec = 'vorbis';\n    } else if (/^A_FLAC/.test(decodedTrack.rawCodec)) {\n      codec = 'flac';\n    } else if (/^A_OPUS/.test(decodedTrack.rawCodec)) {\n      codec = 'opus';\n    }\n\n    decodedTrack.codec = codec;\n    decodedTracks.push(decodedTrack);\n  });\n  return decodedTracks.sort(function (a, b) {\n    return a.number - b.number;\n  });\n};\nexport var parseData = function parseData(data, tracks) {\n  var allBlocks = [];\n  var segment = findEbml(data, [EBML_TAGS.Segment])[0];\n  var timestampScale = findEbml(segment, [EBML_TAGS.SegmentInfo, EBML_TAGS.TimestampScale])[0]; // in nanoseconds, defaults to 1ms\n\n  if (timestampScale && timestampScale.length) {\n    timestampScale = bytesToNumber(timestampScale);\n  } else {\n    timestampScale = 1000000;\n  }\n\n  var clusters = findEbml(segment, [EBML_TAGS.Cluster]);\n\n  if (!tracks) {\n    tracks = parseTracks(segment);\n  }\n\n  clusters.forEach(function (cluster, ci) {\n    var simpleBlocks = findEbml(cluster, [EBML_TAGS.SimpleBlock]).map(function (b) {\n      return {\n        type: 'simple',\n        data: b\n      };\n    });\n    var blockGroups = findEbml(cluster, [EBML_TAGS.BlockGroup]).map(function (b) {\n      return {\n        type: 'group',\n        data: b\n      };\n    });\n    var timestamp = findEbml(cluster, [EBML_TAGS.Timestamp])[0] || 0;\n\n    if (timestamp && timestamp.length) {\n      timestamp = bytesToNumber(timestamp);\n    } // get all blocks then sort them into the correct order\n\n\n    var blocks = simpleBlocks.concat(blockGroups).sort(function (a, b) {\n      return a.data.byteOffset - b.data.byteOffset;\n    });\n    blocks.forEach(function (block, bi) {\n      var decoded = decodeBlock(block.data, block.type, timestampScale, timestamp);\n      allBlocks.push(decoded);\n    });\n  });\n  return {\n    tracks: tracks,\n    blocks: allBlocks\n  };\n};","map":{"version":3,"names":["toUint8","bytesToNumber","bytesMatch","bytesToString","numberToBytes","padStart","getAvcCodec","getHvcCodec","getAv1Codec","EBML_TAGS","EBML","DocType","Segment","SegmentInfo","Tracks","Track","TrackNumber","DefaultDuration","TrackEntry","TrackType","FlagDefault","CodecID","CodecPrivate","VideoTrack","AudioTrack","Cluster","Timestamp","TimestampScale","BlockGroup","BlockDuration","Block","SimpleBlock","LENGTH_TABLE","getLength","byte","len","i","length","getvint","bytes","offset","removeLength","signed","valueBytes","subarray","Array","prototype","slice","call","value","normalizePath","path","match","map","p","normalizePaths","paths","isArray","getInfinityDataSize","id","innerid","dataHeader","findEbml","results","dataStart","dataEnd","data","push","concat","totalLength","decodeBlock","block","type","timestampScale","clusterTimestamp","duration","dv","DataView","buffer","byteOffset","byteLength","trackNumber","timestamp","getInt16","flags","ptsdts","parsed","keyframe","invisible","lacing","discardable","frames","pts","dts","numberOfFrames","frameSizes","sizeOfFrame","_i","size","_size","_i2","vint","forEach","parseVp9Private","params","val","profile","level","bitDepth","chromaSubsampling","parseTracks","decodedTracks","tracks","track","trackType","decodedTrack","rawCodec","codecPrivate","number","defaultDuration","default","rawData","codec","test","toString","_parseVp9Private","matrixCoefficients","videoFullRangeFlag","transferCharacteristics","colourPrimaries","sort","a","b","parseData","allBlocks","segment","clusters","cluster","ci","simpleBlocks","blockGroups","blocks","bi","decoded"],"sources":["C:/office/xampp/htdocs/softtech_it_landing/node_modules/@videojs/vhs-utils/es/ebml-helpers.js"],"sourcesContent":["import { toUint8, bytesToNumber, bytesMatch, bytesToString, numberToBytes, padStart } from './byte-helpers';\nimport { getAvcCodec, getHvcCodec, getAv1Codec } from './codec-helpers.js'; // relevant specs for this parser:\n// https://matroska-org.github.io/libebml/specs.html\n// https://www.matroska.org/technical/elements.html\n// https://www.webmproject.org/docs/container/\n\nexport var EBML_TAGS = {\n  EBML: toUint8([0x1A, 0x45, 0xDF, 0xA3]),\n  DocType: toUint8([0x42, 0x82]),\n  Segment: toUint8([0x18, 0x53, 0x80, 0x67]),\n  SegmentInfo: toUint8([0x15, 0x49, 0xA9, 0x66]),\n  Tracks: toUint8([0x16, 0x54, 0xAE, 0x6B]),\n  Track: toUint8([0xAE]),\n  TrackNumber: toUint8([0xd7]),\n  DefaultDuration: toUint8([0x23, 0xe3, 0x83]),\n  TrackEntry: toUint8([0xAE]),\n  TrackType: toUint8([0x83]),\n  FlagDefault: toUint8([0x88]),\n  CodecID: toUint8([0x86]),\n  CodecPrivate: toUint8([0x63, 0xA2]),\n  VideoTrack: toUint8([0xe0]),\n  AudioTrack: toUint8([0xe1]),\n  // Not used yet, but will be used for live webm/mkv\n  // see https://www.matroska.org/technical/basics.html#block-structure\n  // see https://www.matroska.org/technical/basics.html#simpleblock-structure\n  Cluster: toUint8([0x1F, 0x43, 0xB6, 0x75]),\n  Timestamp: toUint8([0xE7]),\n  TimestampScale: toUint8([0x2A, 0xD7, 0xB1]),\n  BlockGroup: toUint8([0xA0]),\n  BlockDuration: toUint8([0x9B]),\n  Block: toUint8([0xA1]),\n  SimpleBlock: toUint8([0xA3])\n};\n/**\n * This is a simple table to determine the length\n * of things in ebml. The length is one based (starts at 1,\n * rather than zero) and for every zero bit before a one bit\n * we add one to length. We also need this table because in some\n * case we have to xor all the length bits from another value.\n */\n\nvar LENGTH_TABLE = [128, 64, 32, 16, 8, 4, 2, 1];\n\nvar getLength = function getLength(byte) {\n  var len = 1;\n\n  for (var i = 0; i < LENGTH_TABLE.length; i++) {\n    if (byte & LENGTH_TABLE[i]) {\n      break;\n    }\n\n    len++;\n  }\n\n  return len;\n}; // length in ebml is stored in the first 4 to 8 bits\n// of the first byte. 4 for the id length and 8 for the\n// data size length. Length is measured by converting the number to binary\n// then 1 + the number of zeros before a 1 is encountered starting\n// from the left.\n\n\nvar getvint = function getvint(bytes, offset, removeLength, signed) {\n  if (removeLength === void 0) {\n    removeLength = true;\n  }\n\n  if (signed === void 0) {\n    signed = false;\n  }\n\n  var length = getLength(bytes[offset]);\n  var valueBytes = bytes.subarray(offset, offset + length); // NOTE that we do **not** subarray here because we need to copy these bytes\n  // as they will be modified below to remove the dataSizeLen bits and we do not\n  // want to modify the original data. normally we could just call slice on\n  // uint8array but ie 11 does not support that...\n\n  if (removeLength) {\n    valueBytes = Array.prototype.slice.call(bytes, offset, offset + length);\n    valueBytes[0] ^= LENGTH_TABLE[length - 1];\n  }\n\n  return {\n    length: length,\n    value: bytesToNumber(valueBytes, {\n      signed: signed\n    }),\n    bytes: valueBytes\n  };\n};\n\nvar normalizePath = function normalizePath(path) {\n  if (typeof path === 'string') {\n    return path.match(/.{1,2}/g).map(function (p) {\n      return normalizePath(p);\n    });\n  }\n\n  if (typeof path === 'number') {\n    return numberToBytes(path);\n  }\n\n  return path;\n};\n\nvar normalizePaths = function normalizePaths(paths) {\n  if (!Array.isArray(paths)) {\n    return [normalizePath(paths)];\n  }\n\n  return paths.map(function (p) {\n    return normalizePath(p);\n  });\n};\n\nvar getInfinityDataSize = function getInfinityDataSize(id, bytes, offset) {\n  if (offset >= bytes.length) {\n    return bytes.length;\n  }\n\n  var innerid = getvint(bytes, offset, false);\n\n  if (bytesMatch(id.bytes, innerid.bytes)) {\n    return offset;\n  }\n\n  var dataHeader = getvint(bytes, offset + innerid.length);\n  return getInfinityDataSize(id, bytes, offset + dataHeader.length + dataHeader.value + innerid.length);\n};\n/**\n * Notes on the EBLM format.\n *\n * EBLM uses \"vints\" tags. Every vint tag contains\n * two parts\n *\n * 1. The length from the first byte. You get this by\n *    converting the byte to binary and counting the zeros\n *    before a 1. Then you add 1 to that. Examples\n *    00011111 = length 4 because there are 3 zeros before a 1.\n *    00100000 = length 3 because there are 2 zeros before a 1.\n *    00000011 = length 7 because there are 6 zeros before a 1.\n *\n * 2. The bits used for length are removed from the first byte\n *    Then all the bytes are merged into a value. NOTE: this\n *    is not the case for id ebml tags as there id includes\n *    length bits.\n *\n */\n\n\nexport var findEbml = function findEbml(bytes, paths) {\n  paths = normalizePaths(paths);\n  bytes = toUint8(bytes);\n  var results = [];\n\n  if (!paths.length) {\n    return results;\n  }\n\n  var i = 0;\n\n  while (i < bytes.length) {\n    var id = getvint(bytes, i, false);\n    var dataHeader = getvint(bytes, i + id.length);\n    var dataStart = i + id.length + dataHeader.length; // dataSize is unknown or this is a live stream\n\n    if (dataHeader.value === 0x7f) {\n      dataHeader.value = getInfinityDataSize(id, bytes, dataStart);\n\n      if (dataHeader.value !== bytes.length) {\n        dataHeader.value -= dataStart;\n      }\n    }\n\n    var dataEnd = dataStart + dataHeader.value > bytes.length ? bytes.length : dataStart + dataHeader.value;\n    var data = bytes.subarray(dataStart, dataEnd);\n\n    if (bytesMatch(paths[0], id.bytes)) {\n      if (paths.length === 1) {\n        // this is the end of the paths and we've found the tag we were\n        // looking for\n        results.push(data);\n      } else {\n        // recursively search for the next tag inside of the data\n        // of this one\n        results = results.concat(findEbml(data, paths.slice(1)));\n      }\n    }\n\n    var totalLength = id.length + dataHeader.length + data.length; // move past this tag entirely, we are not looking for it\n\n    i += totalLength;\n  }\n\n  return results;\n}; // see https://www.matroska.org/technical/basics.html#block-structure\n\nexport var decodeBlock = function decodeBlock(block, type, timestampScale, clusterTimestamp) {\n  var duration;\n\n  if (type === 'group') {\n    duration = findEbml(block, [EBML_TAGS.BlockDuration])[0];\n\n    if (duration) {\n      duration = bytesToNumber(duration);\n      duration = 1 / timestampScale * duration * timestampScale / 1000;\n    }\n\n    block = findEbml(block, [EBML_TAGS.Block])[0];\n    type = 'block'; // treat data as a block after this point\n  }\n\n  var dv = new DataView(block.buffer, block.byteOffset, block.byteLength);\n  var trackNumber = getvint(block, 0);\n  var timestamp = dv.getInt16(trackNumber.length, false);\n  var flags = block[trackNumber.length + 2];\n  var data = block.subarray(trackNumber.length + 3); // pts/dts in seconds\n\n  var ptsdts = 1 / timestampScale * (clusterTimestamp + timestamp) * timestampScale / 1000; // return the frame\n\n  var parsed = {\n    duration: duration,\n    trackNumber: trackNumber.value,\n    keyframe: type === 'simple' && flags >> 7 === 1,\n    invisible: (flags & 0x08) >> 3 === 1,\n    lacing: (flags & 0x06) >> 1,\n    discardable: type === 'simple' && (flags & 0x01) === 1,\n    frames: [],\n    pts: ptsdts,\n    dts: ptsdts,\n    timestamp: timestamp\n  };\n\n  if (!parsed.lacing) {\n    parsed.frames.push(data);\n    return parsed;\n  }\n\n  var numberOfFrames = data[0] + 1;\n  var frameSizes = [];\n  var offset = 1; // Fixed\n\n  if (parsed.lacing === 2) {\n    var sizeOfFrame = (data.length - offset) / numberOfFrames;\n\n    for (var i = 0; i < numberOfFrames; i++) {\n      frameSizes.push(sizeOfFrame);\n    }\n  } // xiph\n\n\n  if (parsed.lacing === 1) {\n    for (var _i = 0; _i < numberOfFrames - 1; _i++) {\n      var size = 0;\n\n      do {\n        size += data[offset];\n        offset++;\n      } while (data[offset - 1] === 0xFF);\n\n      frameSizes.push(size);\n    }\n  } // ebml\n\n\n  if (parsed.lacing === 3) {\n    // first vint is unsinged\n    // after that vints are singed and\n    // based on a compounding size\n    var _size = 0;\n\n    for (var _i2 = 0; _i2 < numberOfFrames - 1; _i2++) {\n      var vint = _i2 === 0 ? getvint(data, offset) : getvint(data, offset, true, true);\n      _size += vint.value;\n      frameSizes.push(_size);\n      offset += vint.length;\n    }\n  }\n\n  frameSizes.forEach(function (size) {\n    parsed.frames.push(data.subarray(offset, offset + size));\n    offset += size;\n  });\n  return parsed;\n}; // VP9 Codec Feature Metadata (CodecPrivate)\n// https://www.webmproject.org/docs/container/\n\nvar parseVp9Private = function parseVp9Private(bytes) {\n  var i = 0;\n  var params = {};\n\n  while (i < bytes.length) {\n    var id = bytes[i] & 0x7f;\n    var len = bytes[i + 1];\n    var val = void 0;\n\n    if (len === 1) {\n      val = bytes[i + 2];\n    } else {\n      val = bytes.subarray(i + 2, i + 2 + len);\n    }\n\n    if (id === 1) {\n      params.profile = val;\n    } else if (id === 2) {\n      params.level = val;\n    } else if (id === 3) {\n      params.bitDepth = val;\n    } else if (id === 4) {\n      params.chromaSubsampling = val;\n    } else {\n      params[id] = val;\n    }\n\n    i += 2 + len;\n  }\n\n  return params;\n};\n\nexport var parseTracks = function parseTracks(bytes) {\n  bytes = toUint8(bytes);\n  var decodedTracks = [];\n  var tracks = findEbml(bytes, [EBML_TAGS.Segment, EBML_TAGS.Tracks, EBML_TAGS.Track]);\n\n  if (!tracks.length) {\n    tracks = findEbml(bytes, [EBML_TAGS.Tracks, EBML_TAGS.Track]);\n  }\n\n  if (!tracks.length) {\n    tracks = findEbml(bytes, [EBML_TAGS.Track]);\n  }\n\n  if (!tracks.length) {\n    return decodedTracks;\n  }\n\n  tracks.forEach(function (track) {\n    var trackType = findEbml(track, EBML_TAGS.TrackType)[0];\n\n    if (!trackType || !trackType.length) {\n      return;\n    } // 1 is video, 2 is audio, 17 is subtitle\n    // other values are unimportant in this context\n\n\n    if (trackType[0] === 1) {\n      trackType = 'video';\n    } else if (trackType[0] === 2) {\n      trackType = 'audio';\n    } else if (trackType[0] === 17) {\n      trackType = 'subtitle';\n    } else {\n      return;\n    } // todo parse language\n\n\n    var decodedTrack = {\n      rawCodec: bytesToString(findEbml(track, [EBML_TAGS.CodecID])[0]),\n      type: trackType,\n      codecPrivate: findEbml(track, [EBML_TAGS.CodecPrivate])[0],\n      number: bytesToNumber(findEbml(track, [EBML_TAGS.TrackNumber])[0]),\n      defaultDuration: bytesToNumber(findEbml(track, [EBML_TAGS.DefaultDuration])[0]),\n      default: findEbml(track, [EBML_TAGS.FlagDefault])[0],\n      rawData: track\n    };\n    var codec = '';\n\n    if (/V_MPEG4\\/ISO\\/AVC/.test(decodedTrack.rawCodec)) {\n      codec = \"avc1.\" + getAvcCodec(decodedTrack.codecPrivate);\n    } else if (/V_MPEGH\\/ISO\\/HEVC/.test(decodedTrack.rawCodec)) {\n      codec = \"hev1.\" + getHvcCodec(decodedTrack.codecPrivate);\n    } else if (/V_MPEG4\\/ISO\\/ASP/.test(decodedTrack.rawCodec)) {\n      if (decodedTrack.codecPrivate) {\n        codec = 'mp4v.20.' + decodedTrack.codecPrivate[4].toString();\n      } else {\n        codec = 'mp4v.20.9';\n      }\n    } else if (/^V_THEORA/.test(decodedTrack.rawCodec)) {\n      codec = 'theora';\n    } else if (/^V_VP8/.test(decodedTrack.rawCodec)) {\n      codec = 'vp8';\n    } else if (/^V_VP9/.test(decodedTrack.rawCodec)) {\n      if (decodedTrack.codecPrivate) {\n        var _parseVp9Private = parseVp9Private(decodedTrack.codecPrivate),\n            profile = _parseVp9Private.profile,\n            level = _parseVp9Private.level,\n            bitDepth = _parseVp9Private.bitDepth,\n            chromaSubsampling = _parseVp9Private.chromaSubsampling;\n\n        codec = 'vp09.';\n        codec += padStart(profile, 2, '0') + \".\";\n        codec += padStart(level, 2, '0') + \".\";\n        codec += padStart(bitDepth, 2, '0') + \".\";\n        codec += \"\" + padStart(chromaSubsampling, 2, '0'); // Video -> Colour -> Ebml name\n\n        var matrixCoefficients = findEbml(track, [0xE0, [0x55, 0xB0], [0x55, 0xB1]])[0] || [];\n        var videoFullRangeFlag = findEbml(track, [0xE0, [0x55, 0xB0], [0x55, 0xB9]])[0] || [];\n        var transferCharacteristics = findEbml(track, [0xE0, [0x55, 0xB0], [0x55, 0xBA]])[0] || [];\n        var colourPrimaries = findEbml(track, [0xE0, [0x55, 0xB0], [0x55, 0xBB]])[0] || []; // if we find any optional codec parameter specify them all.\n\n        if (matrixCoefficients.length || videoFullRangeFlag.length || transferCharacteristics.length || colourPrimaries.length) {\n          codec += \".\" + padStart(colourPrimaries[0], 2, '0');\n          codec += \".\" + padStart(transferCharacteristics[0], 2, '0');\n          codec += \".\" + padStart(matrixCoefficients[0], 2, '0');\n          codec += \".\" + padStart(videoFullRangeFlag[0], 2, '0');\n        }\n      } else {\n        codec = 'vp9';\n      }\n    } else if (/^V_AV1/.test(decodedTrack.rawCodec)) {\n      codec = \"av01.\" + getAv1Codec(decodedTrack.codecPrivate);\n    } else if (/A_ALAC/.test(decodedTrack.rawCodec)) {\n      codec = 'alac';\n    } else if (/A_MPEG\\/L2/.test(decodedTrack.rawCodec)) {\n      codec = 'mp2';\n    } else if (/A_MPEG\\/L3/.test(decodedTrack.rawCodec)) {\n      codec = 'mp3';\n    } else if (/^A_AAC/.test(decodedTrack.rawCodec)) {\n      if (decodedTrack.codecPrivate) {\n        codec = 'mp4a.40.' + (decodedTrack.codecPrivate[0] >>> 3).toString();\n      } else {\n        codec = 'mp4a.40.2';\n      }\n    } else if (/^A_AC3/.test(decodedTrack.rawCodec)) {\n      codec = 'ac-3';\n    } else if (/^A_PCM/.test(decodedTrack.rawCodec)) {\n      codec = 'pcm';\n    } else if (/^A_MS\\/ACM/.test(decodedTrack.rawCodec)) {\n      codec = 'speex';\n    } else if (/^A_EAC3/.test(decodedTrack.rawCodec)) {\n      codec = 'ec-3';\n    } else if (/^A_VORBIS/.test(decodedTrack.rawCodec)) {\n      codec = 'vorbis';\n    } else if (/^A_FLAC/.test(decodedTrack.rawCodec)) {\n      codec = 'flac';\n    } else if (/^A_OPUS/.test(decodedTrack.rawCodec)) {\n      codec = 'opus';\n    }\n\n    decodedTrack.codec = codec;\n    decodedTracks.push(decodedTrack);\n  });\n  return decodedTracks.sort(function (a, b) {\n    return a.number - b.number;\n  });\n};\nexport var parseData = function parseData(data, tracks) {\n  var allBlocks = [];\n  var segment = findEbml(data, [EBML_TAGS.Segment])[0];\n  var timestampScale = findEbml(segment, [EBML_TAGS.SegmentInfo, EBML_TAGS.TimestampScale])[0]; // in nanoseconds, defaults to 1ms\n\n  if (timestampScale && timestampScale.length) {\n    timestampScale = bytesToNumber(timestampScale);\n  } else {\n    timestampScale = 1000000;\n  }\n\n  var clusters = findEbml(segment, [EBML_TAGS.Cluster]);\n\n  if (!tracks) {\n    tracks = parseTracks(segment);\n  }\n\n  clusters.forEach(function (cluster, ci) {\n    var simpleBlocks = findEbml(cluster, [EBML_TAGS.SimpleBlock]).map(function (b) {\n      return {\n        type: 'simple',\n        data: b\n      };\n    });\n    var blockGroups = findEbml(cluster, [EBML_TAGS.BlockGroup]).map(function (b) {\n      return {\n        type: 'group',\n        data: b\n      };\n    });\n    var timestamp = findEbml(cluster, [EBML_TAGS.Timestamp])[0] || 0;\n\n    if (timestamp && timestamp.length) {\n      timestamp = bytesToNumber(timestamp);\n    } // get all blocks then sort them into the correct order\n\n\n    var blocks = simpleBlocks.concat(blockGroups).sort(function (a, b) {\n      return a.data.byteOffset - b.data.byteOffset;\n    });\n    blocks.forEach(function (block, bi) {\n      var decoded = decodeBlock(block.data, block.type, timestampScale, timestamp);\n      allBlocks.push(decoded);\n    });\n  });\n  return {\n    tracks: tracks,\n    blocks: allBlocks\n  };\n};"],"mappings":"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"},"metadata":{},"sourceType":"module"}