{"ast":null,"code":"import \"core-js/modules/es.typed-array.at.js\";\nimport \"core-js/modules/es.typed-array.set.js\";\nimport { bytesMatch, toUint8 } from './byte-helpers.js';\nexport var NAL_TYPE_ONE = toUint8([0x00, 0x00, 0x00, 0x01]);\nexport var NAL_TYPE_TWO = toUint8([0x00, 0x00, 0x01]);\nexport var EMULATION_PREVENTION = toUint8([0x00, 0x00, 0x03]);\n/**\n * Expunge any \"Emulation Prevention\" bytes from a \"Raw Byte\n * Sequence Payload\"\n *\n * @param data {Uint8Array} the bytes of a RBSP from a NAL\n * unit\n * @return {Uint8Array} the RBSP without any Emulation\n * Prevention Bytes\n */\n\nexport var discardEmulationPreventionBytes = function discardEmulationPreventionBytes(bytes) {\n  var positions = [];\n  var i = 1; // Find all `Emulation Prevention Bytes`\n\n  while (i < bytes.length - 2) {\n    if (bytesMatch(bytes.subarray(i, i + 3), EMULATION_PREVENTION)) {\n      positions.push(i + 2);\n      i++;\n    }\n\n    i++;\n  } // If no Emulation Prevention Bytes were found just return the original\n  // array\n\n\n  if (positions.length === 0) {\n    return bytes;\n  } // Create a new array to hold the NAL unit data\n\n\n  var newLength = bytes.length - positions.length;\n  var newData = new Uint8Array(newLength);\n  var sourceIndex = 0;\n\n  for (i = 0; i < newLength; sourceIndex++, i++) {\n    if (sourceIndex === positions[0]) {\n      // Skip this byte\n      sourceIndex++; // Remove this position index\n\n      positions.shift();\n    }\n\n    newData[i] = bytes[sourceIndex];\n  }\n\n  return newData;\n};\nexport var findNal = function findNal(bytes, dataType, types, nalLimit) {\n  if (nalLimit === void 0) {\n    nalLimit = Infinity;\n  }\n\n  bytes = toUint8(bytes);\n  types = [].concat(types);\n  var i = 0;\n  var nalStart;\n  var nalsFound = 0; // keep searching until:\n  // we reach the end of bytes\n  // we reach the maximum number of nals they want to seach\n  // NOTE: that we disregard nalLimit when we have found the start\n  // of the nal we want so that we can find the end of the nal we want.\n\n  while (i < bytes.length && (nalsFound < nalLimit || nalStart)) {\n    var nalOffset = void 0;\n\n    if (bytesMatch(bytes.subarray(i), NAL_TYPE_ONE)) {\n      nalOffset = 4;\n    } else if (bytesMatch(bytes.subarray(i), NAL_TYPE_TWO)) {\n      nalOffset = 3;\n    } // we are unsynced,\n    // find the next nal unit\n\n\n    if (!nalOffset) {\n      i++;\n      continue;\n    }\n\n    nalsFound++;\n\n    if (nalStart) {\n      return discardEmulationPreventionBytes(bytes.subarray(nalStart, i));\n    }\n\n    var nalType = void 0;\n\n    if (dataType === 'h264') {\n      nalType = bytes[i + nalOffset] & 0x1f;\n    } else if (dataType === 'h265') {\n      nalType = bytes[i + nalOffset] >> 1 & 0x3f;\n    }\n\n    if (types.indexOf(nalType) !== -1) {\n      nalStart = i + nalOffset;\n    } // nal header is 1 length for h264, and 2 for h265\n\n\n    i += nalOffset + (dataType === 'h264' ? 1 : 2);\n  }\n\n  return bytes.subarray(0, 0);\n};\nexport var findH264Nal = function findH264Nal(bytes, type, nalLimit) {\n  return findNal(bytes, 'h264', type, nalLimit);\n};\nexport var findH265Nal = function findH265Nal(bytes, type, nalLimit) {\n  return findNal(bytes, 'h265', type, nalLimit);\n};","map":{"version":3,"names":["bytesMatch","toUint8","NAL_TYPE_ONE","NAL_TYPE_TWO","EMULATION_PREVENTION","discardEmulationPreventionBytes","bytes","positions","i","length","subarray","push","newLength","newData","Uint8Array","sourceIndex","shift","findNal","dataType","types","nalLimit","Infinity","concat","nalStart","nalsFound","nalOffset","nalType","indexOf","findH264Nal","type","findH265Nal"],"sources":["C:/office/xampp/htdocs/softtech_it_landing/node_modules/@videojs/vhs-utils/es/nal-helpers.js"],"sourcesContent":["import { bytesMatch, toUint8 } from './byte-helpers.js';\nexport var NAL_TYPE_ONE = toUint8([0x00, 0x00, 0x00, 0x01]);\nexport var NAL_TYPE_TWO = toUint8([0x00, 0x00, 0x01]);\nexport var EMULATION_PREVENTION = toUint8([0x00, 0x00, 0x03]);\n/**\n * Expunge any \"Emulation Prevention\" bytes from a \"Raw Byte\n * Sequence Payload\"\n *\n * @param data {Uint8Array} the bytes of a RBSP from a NAL\n * unit\n * @return {Uint8Array} the RBSP without any Emulation\n * Prevention Bytes\n */\n\nexport var discardEmulationPreventionBytes = function discardEmulationPreventionBytes(bytes) {\n  var positions = [];\n  var i = 1; // Find all `Emulation Prevention Bytes`\n\n  while (i < bytes.length - 2) {\n    if (bytesMatch(bytes.subarray(i, i + 3), EMULATION_PREVENTION)) {\n      positions.push(i + 2);\n      i++;\n    }\n\n    i++;\n  } // If no Emulation Prevention Bytes were found just return the original\n  // array\n\n\n  if (positions.length === 0) {\n    return bytes;\n  } // Create a new array to hold the NAL unit data\n\n\n  var newLength = bytes.length - positions.length;\n  var newData = new Uint8Array(newLength);\n  var sourceIndex = 0;\n\n  for (i = 0; i < newLength; sourceIndex++, i++) {\n    if (sourceIndex === positions[0]) {\n      // Skip this byte\n      sourceIndex++; // Remove this position index\n\n      positions.shift();\n    }\n\n    newData[i] = bytes[sourceIndex];\n  }\n\n  return newData;\n};\nexport var findNal = function findNal(bytes, dataType, types, nalLimit) {\n  if (nalLimit === void 0) {\n    nalLimit = Infinity;\n  }\n\n  bytes = toUint8(bytes);\n  types = [].concat(types);\n  var i = 0;\n  var nalStart;\n  var nalsFound = 0; // keep searching until:\n  // we reach the end of bytes\n  // we reach the maximum number of nals they want to seach\n  // NOTE: that we disregard nalLimit when we have found the start\n  // of the nal we want so that we can find the end of the nal we want.\n\n  while (i < bytes.length && (nalsFound < nalLimit || nalStart)) {\n    var nalOffset = void 0;\n\n    if (bytesMatch(bytes.subarray(i), NAL_TYPE_ONE)) {\n      nalOffset = 4;\n    } else if (bytesMatch(bytes.subarray(i), NAL_TYPE_TWO)) {\n      nalOffset = 3;\n    } // we are unsynced,\n    // find the next nal unit\n\n\n    if (!nalOffset) {\n      i++;\n      continue;\n    }\n\n    nalsFound++;\n\n    if (nalStart) {\n      return discardEmulationPreventionBytes(bytes.subarray(nalStart, i));\n    }\n\n    var nalType = void 0;\n\n    if (dataType === 'h264') {\n      nalType = bytes[i + nalOffset] & 0x1f;\n    } else if (dataType === 'h265') {\n      nalType = bytes[i + nalOffset] >> 1 & 0x3f;\n    }\n\n    if (types.indexOf(nalType) !== -1) {\n      nalStart = i + nalOffset;\n    } // nal header is 1 length for h264, and 2 for h265\n\n\n    i += nalOffset + (dataType === 'h264' ? 1 : 2);\n  }\n\n  return bytes.subarray(0, 0);\n};\nexport var findH264Nal = function findH264Nal(bytes, type, nalLimit) {\n  return findNal(bytes, 'h264', type, nalLimit);\n};\nexport var findH265Nal = function findH265Nal(bytes, type, nalLimit) {\n  return findNal(bytes, 'h265', type, nalLimit);\n};"],"mappings":"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"},"metadata":{},"sourceType":"module"}