{"ast":null,"code":"import { stringToBytes, toUint8, bytesMatch, bytesToString, toHexString, padStart, bytesToNumber } from './byte-helpers.js';\nimport { getAvcCodec, getHvcCodec, getAv1Codec } from './codec-helpers.js';\nimport { parseOpusHead } from './opus-helpers.js';\n\nvar normalizePath = function normalizePath(path) {\n  if (typeof path === 'string') {\n    return stringToBytes(path);\n  }\n\n  if (typeof path === 'number') {\n    return path;\n  }\n\n  return path;\n};\n\nvar normalizePaths = function normalizePaths(paths) {\n  if (!Array.isArray(paths)) {\n    return [normalizePath(paths)];\n  }\n\n  return paths.map(function (p) {\n    return normalizePath(p);\n  });\n};\n\nvar DESCRIPTORS;\nexport var parseDescriptors = function parseDescriptors(bytes) {\n  bytes = toUint8(bytes);\n  var results = [];\n  var i = 0;\n\n  while (bytes.length > i) {\n    var tag = bytes[i];\n    var size = 0;\n    var headerSize = 0; // tag\n\n    headerSize++;\n    var byte = bytes[headerSize]; // first byte\n\n    headerSize++;\n\n    while (byte & 0x80) {\n      size = (byte & 0x7F) << 7;\n      byte = bytes[headerSize];\n      headerSize++;\n    }\n\n    size += byte & 0x7F;\n\n    for (var z = 0; z < DESCRIPTORS.length; z++) {\n      var _DESCRIPTORS$z = DESCRIPTORS[z],\n          id = _DESCRIPTORS$z.id,\n          parser = _DESCRIPTORS$z.parser;\n\n      if (tag === id) {\n        results.push(parser(bytes.subarray(headerSize, headerSize + size)));\n        break;\n      }\n    }\n\n    i += size + headerSize;\n  }\n\n  return results;\n};\nDESCRIPTORS = [{\n  id: 0x03,\n  parser: function parser(bytes) {\n    var desc = {\n      tag: 0x03,\n      id: bytes[0] << 8 | bytes[1],\n      flags: bytes[2],\n      size: 3,\n      dependsOnEsId: 0,\n      ocrEsId: 0,\n      descriptors: [],\n      url: ''\n    }; // depends on es id\n\n    if (desc.flags & 0x80) {\n      desc.dependsOnEsId = bytes[desc.size] << 8 | bytes[desc.size + 1];\n      desc.size += 2;\n    } // url\n\n\n    if (desc.flags & 0x40) {\n      var len = bytes[desc.size];\n      desc.url = bytesToString(bytes.subarray(desc.size + 1, desc.size + 1 + len));\n      desc.size += len;\n    } // ocr es id\n\n\n    if (desc.flags & 0x20) {\n      desc.ocrEsId = bytes[desc.size] << 8 | bytes[desc.size + 1];\n      desc.size += 2;\n    }\n\n    desc.descriptors = parseDescriptors(bytes.subarray(desc.size)) || [];\n    return desc;\n  }\n}, {\n  id: 0x04,\n  parser: function parser(bytes) {\n    // DecoderConfigDescriptor\n    var desc = {\n      tag: 0x04,\n      oti: bytes[0],\n      streamType: bytes[1],\n      bufferSize: bytes[2] << 16 | bytes[3] << 8 | bytes[4],\n      maxBitrate: bytes[5] << 24 | bytes[6] << 16 | bytes[7] << 8 | bytes[8],\n      avgBitrate: bytes[9] << 24 | bytes[10] << 16 | bytes[11] << 8 | bytes[12],\n      descriptors: parseDescriptors(bytes.subarray(13))\n    };\n    return desc;\n  }\n}, {\n  id: 0x05,\n  parser: function parser(bytes) {\n    // DecoderSpecificInfo\n    return {\n      tag: 0x05,\n      bytes: bytes\n    };\n  }\n}, {\n  id: 0x06,\n  parser: function parser(bytes) {\n    // SLConfigDescriptor\n    return {\n      tag: 0x06,\n      bytes: bytes\n    };\n  }\n}];\n/**\n * find any number of boxes by name given a path to it in an iso bmff\n * such as mp4.\n *\n * @param {TypedArray} bytes\n *        bytes for the iso bmff to search for boxes in\n *\n * @param {Uint8Array[]|string[]|string|Uint8Array} name\n *        An array of paths or a single path representing the name\n *        of boxes to search through in bytes. Paths may be\n *        uint8 (character codes) or strings.\n *\n * @param {boolean} [complete=false]\n *        Should we search only for complete boxes on the final path.\n *        This is very useful when you do not want to get back partial boxes\n *        in the case of streaming files.\n *\n * @return {Uint8Array[]}\n *         An array of the end paths that we found.\n */\n\nexport var findBox = function findBox(bytes, paths, complete) {\n  if (complete === void 0) {\n    complete = false;\n  }\n\n  paths = normalizePaths(paths);\n  bytes = toUint8(bytes);\n  var results = [];\n\n  if (!paths.length) {\n    // short-circuit the search for empty paths\n    return results;\n  }\n\n  var i = 0;\n\n  while (i < bytes.length) {\n    var size = (bytes[i] << 24 | bytes[i + 1] << 16 | bytes[i + 2] << 8 | bytes[i + 3]) >>> 0;\n    var type = bytes.subarray(i + 4, i + 8); // invalid box format.\n\n    if (size === 0) {\n      break;\n    }\n\n    var end = i + size;\n\n    if (end > bytes.length) {\n      // this box is bigger than the number of bytes we have\n      // and complete is set, we cannot find any more boxes.\n      if (complete) {\n        break;\n      }\n\n      end = bytes.length;\n    }\n\n    var data = bytes.subarray(i + 8, end);\n\n    if (bytesMatch(type, paths[0])) {\n      if (paths.length === 1) {\n        // this is the end of the path and we've found the box we were\n        // looking for\n        results.push(data);\n      } else {\n        // recursively search for the next box along the path\n        results.push.apply(results, findBox(data, paths.slice(1), complete));\n      }\n    }\n\n    i = end;\n  } // we've finished searching all of bytes\n\n\n  return results;\n};\n/**\n * Search for a single matching box by name in an iso bmff format like\n * mp4. This function is useful for finding codec boxes which\n * can be placed arbitrarily in sample descriptions depending\n * on the version of the file or file type.\n *\n * @param {TypedArray} bytes\n *        bytes for the iso bmff to search for boxes in\n *\n * @param {string|Uint8Array} name\n *        The name of the box to find.\n *\n * @return {Uint8Array[]}\n *         a subarray of bytes representing the name boxed we found.\n */\n\nexport var findNamedBox = function findNamedBox(bytes, name) {\n  name = normalizePath(name);\n\n  if (!name.length) {\n    // short-circuit the search for empty paths\n    return bytes.subarray(bytes.length);\n  }\n\n  var i = 0;\n\n  while (i < bytes.length) {\n    if (bytesMatch(bytes.subarray(i, i + name.length), name)) {\n      var size = (bytes[i - 4] << 24 | bytes[i - 3] << 16 | bytes[i - 2] << 8 | bytes[i - 1]) >>> 0;\n      var end = size > 1 ? i + size : bytes.byteLength;\n      return bytes.subarray(i + 4, end);\n    }\n\n    i++;\n  } // we've finished searching all of bytes\n\n\n  return bytes.subarray(bytes.length);\n};\n\nvar parseSamples = function parseSamples(data, entrySize, parseEntry) {\n  if (entrySize === void 0) {\n    entrySize = 4;\n  }\n\n  if (parseEntry === void 0) {\n    parseEntry = function parseEntry(d) {\n      return bytesToNumber(d);\n    };\n  }\n\n  var entries = [];\n\n  if (!data || !data.length) {\n    return entries;\n  }\n\n  var entryCount = bytesToNumber(data.subarray(4, 8));\n\n  for (var i = 8; entryCount; i += entrySize, entryCount--) {\n    entries.push(parseEntry(data.subarray(i, i + entrySize)));\n  }\n\n  return entries;\n};\n\nexport var buildFrameTable = function buildFrameTable(stbl, timescale) {\n  var keySamples = parseSamples(findBox(stbl, ['stss'])[0]);\n  var chunkOffsets = parseSamples(findBox(stbl, ['stco'])[0]);\n  var timeToSamples = parseSamples(findBox(stbl, ['stts'])[0], 8, function (entry) {\n    return {\n      sampleCount: bytesToNumber(entry.subarray(0, 4)),\n      sampleDelta: bytesToNumber(entry.subarray(4, 8))\n    };\n  });\n  var samplesToChunks = parseSamples(findBox(stbl, ['stsc'])[0], 12, function (entry) {\n    return {\n      firstChunk: bytesToNumber(entry.subarray(0, 4)),\n      samplesPerChunk: bytesToNumber(entry.subarray(4, 8)),\n      sampleDescriptionIndex: bytesToNumber(entry.subarray(8, 12))\n    };\n  });\n  var stsz = findBox(stbl, ['stsz'])[0]; // stsz starts with a 4 byte sampleSize which we don't need\n\n  var sampleSizes = parseSamples(stsz && stsz.length && stsz.subarray(4) || null);\n  var frames = [];\n\n  for (var chunkIndex = 0; chunkIndex < chunkOffsets.length; chunkIndex++) {\n    var samplesInChunk = void 0;\n\n    for (var i = 0; i < samplesToChunks.length; i++) {\n      var sampleToChunk = samplesToChunks[i];\n      var isThisOne = chunkIndex + 1 >= sampleToChunk.firstChunk && (i + 1 >= samplesToChunks.length || chunkIndex + 1 < samplesToChunks[i + 1].firstChunk);\n\n      if (isThisOne) {\n        samplesInChunk = sampleToChunk.samplesPerChunk;\n        break;\n      }\n    }\n\n    var chunkOffset = chunkOffsets[chunkIndex];\n\n    for (var _i = 0; _i < samplesInChunk; _i++) {\n      var frameEnd = sampleSizes[frames.length]; // if we don't have key samples every frame is a keyframe\n\n      var keyframe = !keySamples.length;\n\n      if (keySamples.length && keySamples.indexOf(frames.length + 1) !== -1) {\n        keyframe = true;\n      }\n\n      var frame = {\n        keyframe: keyframe,\n        start: chunkOffset,\n        end: chunkOffset + frameEnd\n      };\n\n      for (var k = 0; k < timeToSamples.length; k++) {\n        var _timeToSamples$k = timeToSamples[k],\n            sampleCount = _timeToSamples$k.sampleCount,\n            sampleDelta = _timeToSamples$k.sampleDelta;\n\n        if (frames.length <= sampleCount) {\n          // ms to ns\n          var lastTimestamp = frames.length ? frames[frames.length - 1].timestamp : 0;\n          frame.timestamp = lastTimestamp + sampleDelta / timescale * 1000;\n          frame.duration = sampleDelta;\n          break;\n        }\n      }\n\n      frames.push(frame);\n      chunkOffset += frameEnd;\n    }\n  }\n\n  return frames;\n};\nexport var addSampleDescription = function addSampleDescription(track, bytes) {\n  var codec = bytesToString(bytes.subarray(0, 4));\n\n  if (track.type === 'video') {\n    track.info = track.info || {};\n    track.info.width = bytes[28] << 8 | bytes[29];\n    track.info.height = bytes[30] << 8 | bytes[31];\n  } else if (track.type === 'audio') {\n    track.info = track.info || {};\n    track.info.channels = bytes[20] << 8 | bytes[21];\n    track.info.bitDepth = bytes[22] << 8 | bytes[23];\n    track.info.sampleRate = bytes[28] << 8 | bytes[29];\n  }\n\n  if (codec === 'avc1') {\n    var avcC = findNamedBox(bytes, 'avcC'); // AVCDecoderConfigurationRecord\n\n    codec += \".\" + getAvcCodec(avcC);\n    track.info.avcC = avcC; // TODO: do we need to parse all this?\n\n    /* {\n      configurationVersion: avcC[0],\n      profile: avcC[1],\n      profileCompatibility: avcC[2],\n      level: avcC[3],\n      lengthSizeMinusOne: avcC[4] & 0x3\n    };\n     let spsNalUnitCount = avcC[5] & 0x1F;\n    const spsNalUnits = track.info.avc.spsNalUnits = [];\n     // past spsNalUnitCount\n    let offset = 6;\n     while (spsNalUnitCount--) {\n      const nalLen = avcC[offset] << 8 | avcC[offset + 1];\n       spsNalUnits.push(avcC.subarray(offset + 2, offset + 2 + nalLen));\n       offset += nalLen + 2;\n    }\n    let ppsNalUnitCount = avcC[offset];\n    const ppsNalUnits = track.info.avc.ppsNalUnits = [];\n     // past ppsNalUnitCount\n    offset += 1;\n     while (ppsNalUnitCount--) {\n      const nalLen = avcC[offset] << 8 | avcC[offset + 1];\n       ppsNalUnits.push(avcC.subarray(offset + 2, offset + 2 + nalLen));\n       offset += nalLen + 2;\n    }*/\n    // HEVCDecoderConfigurationRecord\n  } else if (codec === 'hvc1' || codec === 'hev1') {\n    codec += \".\" + getHvcCodec(findNamedBox(bytes, 'hvcC'));\n  } else if (codec === 'mp4a' || codec === 'mp4v') {\n    var esds = findNamedBox(bytes, 'esds');\n    var esDescriptor = parseDescriptors(esds.subarray(4))[0];\n    var decoderConfig = esDescriptor && esDescriptor.descriptors.filter(function (_ref) {\n      var tag = _ref.tag;\n      return tag === 0x04;\n    })[0];\n\n    if (decoderConfig) {\n      // most codecs do not have a further '.'\n      // such as 0xa5 for ac-3 and 0xa6 for e-ac-3\n      codec += '.' + toHexString(decoderConfig.oti);\n\n      if (decoderConfig.oti === 0x40) {\n        codec += '.' + (decoderConfig.descriptors[0].bytes[0] >> 3).toString();\n      } else if (decoderConfig.oti === 0x20) {\n        codec += '.' + decoderConfig.descriptors[0].bytes[4].toString();\n      } else if (decoderConfig.oti === 0xdd) {\n        codec = 'vorbis';\n      }\n    } else if (track.type === 'audio') {\n      codec += '.40.2';\n    } else {\n      codec += '.20.9';\n    }\n  } else if (codec === 'av01') {\n    // AV1DecoderConfigurationRecord\n    codec += \".\" + getAv1Codec(findNamedBox(bytes, 'av1C'));\n  } else if (codec === 'vp09') {\n    // VPCodecConfigurationRecord\n    var vpcC = findNamedBox(bytes, 'vpcC'); // https://www.webmproject.org/vp9/mp4/\n\n    var profile = vpcC[0];\n    var level = vpcC[1];\n    var bitDepth = vpcC[2] >> 4;\n    var chromaSubsampling = (vpcC[2] & 0x0F) >> 1;\n    var videoFullRangeFlag = (vpcC[2] & 0x0F) >> 3;\n    var colourPrimaries = vpcC[3];\n    var transferCharacteristics = vpcC[4];\n    var matrixCoefficients = vpcC[5];\n    codec += \".\" + padStart(profile, 2, '0');\n    codec += \".\" + padStart(level, 2, '0');\n    codec += \".\" + padStart(bitDepth, 2, '0');\n    codec += \".\" + padStart(chromaSubsampling, 2, '0');\n    codec += \".\" + padStart(colourPrimaries, 2, '0');\n    codec += \".\" + padStart(transferCharacteristics, 2, '0');\n    codec += \".\" + padStart(matrixCoefficients, 2, '0');\n    codec += \".\" + padStart(videoFullRangeFlag, 2, '0');\n  } else if (codec === 'theo') {\n    codec = 'theora';\n  } else if (codec === 'spex') {\n    codec = 'speex';\n  } else if (codec === '.mp3') {\n    codec = 'mp4a.40.34';\n  } else if (codec === 'msVo') {\n    codec = 'vorbis';\n  } else if (codec === 'Opus') {\n    codec = 'opus';\n    var dOps = findNamedBox(bytes, 'dOps');\n    track.info.opus = parseOpusHead(dOps); // TODO: should this go into the webm code??\n    // Firefox requires a codecDelay for opus playback\n    // see https://bugzilla.mozilla.org/show_bug.cgi?id=1276238\n\n    track.info.codecDelay = 6500000;\n  } else {\n    codec = codec.toLowerCase();\n  }\n  /* eslint-enable */\n  // flac, ac-3, ec-3, opus\n\n\n  track.codec = codec;\n};\nexport var parseTracks = function parseTracks(bytes, frameTable) {\n  if (frameTable === void 0) {\n    frameTable = true;\n  }\n\n  bytes = toUint8(bytes);\n  var traks = findBox(bytes, ['moov', 'trak'], true);\n  var tracks = [];\n  traks.forEach(function (trak) {\n    var track = {\n      bytes: trak\n    };\n    var mdia = findBox(trak, ['mdia'])[0];\n    var hdlr = findBox(mdia, ['hdlr'])[0];\n    var trakType = bytesToString(hdlr.subarray(8, 12));\n\n    if (trakType === 'soun') {\n      track.type = 'audio';\n    } else if (trakType === 'vide') {\n      track.type = 'video';\n    } else {\n      track.type = trakType;\n    }\n\n    var tkhd = findBox(trak, ['tkhd'])[0];\n\n    if (tkhd) {\n      var view = new DataView(tkhd.buffer, tkhd.byteOffset, tkhd.byteLength);\n      var tkhdVersion = view.getUint8(0);\n      track.number = tkhdVersion === 0 ? view.getUint32(12) : view.getUint32(20);\n    }\n\n    var mdhd = findBox(mdia, ['mdhd'])[0];\n\n    if (mdhd) {\n      // mdhd is a FullBox, meaning it will have its own version as the first byte\n      var version = mdhd[0];\n      var index = version === 0 ? 12 : 20;\n      track.timescale = (mdhd[index] << 24 | mdhd[index + 1] << 16 | mdhd[index + 2] << 8 | mdhd[index + 3]) >>> 0;\n    }\n\n    var stbl = findBox(mdia, ['minf', 'stbl'])[0];\n    var stsd = findBox(stbl, ['stsd'])[0];\n    var descriptionCount = bytesToNumber(stsd.subarray(4, 8));\n    var offset = 8; // add codec and codec info\n\n    while (descriptionCount--) {\n      var len = bytesToNumber(stsd.subarray(offset, offset + 4));\n      var sampleDescriptor = stsd.subarray(offset + 4, offset + 4 + len);\n      addSampleDescription(track, sampleDescriptor);\n      offset += 4 + len;\n    }\n\n    if (frameTable) {\n      track.frameTable = buildFrameTable(stbl, track.timescale);\n    } // codec has no sub parameters\n\n\n    tracks.push(track);\n  });\n  return tracks;\n};\nexport var parseMediaInfo = function parseMediaInfo(bytes) {\n  var mvhd = findBox(bytes, ['moov', 'mvhd'], true)[0];\n\n  if (!mvhd || !mvhd.length) {\n    return;\n  }\n\n  var info = {}; // ms to ns\n  // mvhd v1 has 8 byte duration and other fields too\n\n  if (mvhd[0] === 1) {\n    info.timestampScale = bytesToNumber(mvhd.subarray(20, 24));\n    info.duration = bytesToNumber(mvhd.subarray(24, 32));\n  } else {\n    info.timestampScale = bytesToNumber(mvhd.subarray(12, 16));\n    info.duration = bytesToNumber(mvhd.subarray(16, 20));\n  }\n\n  info.bytes = mvhd;\n  return info;\n};","map":{"version":3,"names":["stringToBytes","toUint8","bytesMatch","bytesToString","toHexString","padStart","bytesToNumber","getAvcCodec","getHvcCodec","getAv1Codec","parseOpusHead","normalizePath","path","normalizePaths","paths","Array","isArray","map","p","DESCRIPTORS","parseDescriptors","bytes","results","i","length","tag","size","headerSize","byte","z","_DESCRIPTORS$z","id","parser","push","subarray","desc","flags","dependsOnEsId","ocrEsId","descriptors","url","len","oti","streamType","bufferSize","maxBitrate","avgBitrate","findBox","complete","type","end","data","apply","slice","findNamedBox","name","byteLength","parseSamples","entrySize","parseEntry","d","entries","entryCount","buildFrameTable","stbl","timescale","keySamples","chunkOffsets","timeToSamples","entry","sampleCount","sampleDelta","samplesToChunks","firstChunk","samplesPerChunk","sampleDescriptionIndex","stsz","sampleSizes","frames","chunkIndex","samplesInChunk","sampleToChunk","isThisOne","chunkOffset","_i","frameEnd","keyframe","indexOf","frame","start","k","_timeToSamples$k","lastTimestamp","timestamp","duration","addSampleDescription","track","codec","info","width","height","channels","bitDepth","sampleRate","avcC","esds","esDescriptor","decoderConfig","filter","_ref","toString","vpcC","profile","level","chromaSubsampling","videoFullRangeFlag","colourPrimaries","transferCharacteristics","matrixCoefficients","dOps","opus","codecDelay","toLowerCase","parseTracks","frameTable","traks","tracks","forEach","trak","mdia","hdlr","trakType","tkhd","view","DataView","buffer","byteOffset","tkhdVersion","getUint8","number","getUint32","mdhd","version","index","stsd","descriptionCount","offset","sampleDescriptor","parseMediaInfo","mvhd","timestampScale"],"sources":["C:/office/xampp/htdocs/softtech_it_landing/node_modules/@videojs/vhs-utils/es/mp4-helpers.js"],"sourcesContent":["import { stringToBytes, toUint8, bytesMatch, bytesToString, toHexString, padStart, bytesToNumber } from './byte-helpers.js';\nimport { getAvcCodec, getHvcCodec, getAv1Codec } from './codec-helpers.js';\nimport { parseOpusHead } from './opus-helpers.js';\n\nvar normalizePath = function normalizePath(path) {\n  if (typeof path === 'string') {\n    return stringToBytes(path);\n  }\n\n  if (typeof path === 'number') {\n    return path;\n  }\n\n  return path;\n};\n\nvar normalizePaths = function normalizePaths(paths) {\n  if (!Array.isArray(paths)) {\n    return [normalizePath(paths)];\n  }\n\n  return paths.map(function (p) {\n    return normalizePath(p);\n  });\n};\n\nvar DESCRIPTORS;\nexport var parseDescriptors = function parseDescriptors(bytes) {\n  bytes = toUint8(bytes);\n  var results = [];\n  var i = 0;\n\n  while (bytes.length > i) {\n    var tag = bytes[i];\n    var size = 0;\n    var headerSize = 0; // tag\n\n    headerSize++;\n    var byte = bytes[headerSize]; // first byte\n\n    headerSize++;\n\n    while (byte & 0x80) {\n      size = (byte & 0x7F) << 7;\n      byte = bytes[headerSize];\n      headerSize++;\n    }\n\n    size += byte & 0x7F;\n\n    for (var z = 0; z < DESCRIPTORS.length; z++) {\n      var _DESCRIPTORS$z = DESCRIPTORS[z],\n          id = _DESCRIPTORS$z.id,\n          parser = _DESCRIPTORS$z.parser;\n\n      if (tag === id) {\n        results.push(parser(bytes.subarray(headerSize, headerSize + size)));\n        break;\n      }\n    }\n\n    i += size + headerSize;\n  }\n\n  return results;\n};\nDESCRIPTORS = [{\n  id: 0x03,\n  parser: function parser(bytes) {\n    var desc = {\n      tag: 0x03,\n      id: bytes[0] << 8 | bytes[1],\n      flags: bytes[2],\n      size: 3,\n      dependsOnEsId: 0,\n      ocrEsId: 0,\n      descriptors: [],\n      url: ''\n    }; // depends on es id\n\n    if (desc.flags & 0x80) {\n      desc.dependsOnEsId = bytes[desc.size] << 8 | bytes[desc.size + 1];\n      desc.size += 2;\n    } // url\n\n\n    if (desc.flags & 0x40) {\n      var len = bytes[desc.size];\n      desc.url = bytesToString(bytes.subarray(desc.size + 1, desc.size + 1 + len));\n      desc.size += len;\n    } // ocr es id\n\n\n    if (desc.flags & 0x20) {\n      desc.ocrEsId = bytes[desc.size] << 8 | bytes[desc.size + 1];\n      desc.size += 2;\n    }\n\n    desc.descriptors = parseDescriptors(bytes.subarray(desc.size)) || [];\n    return desc;\n  }\n}, {\n  id: 0x04,\n  parser: function parser(bytes) {\n    // DecoderConfigDescriptor\n    var desc = {\n      tag: 0x04,\n      oti: bytes[0],\n      streamType: bytes[1],\n      bufferSize: bytes[2] << 16 | bytes[3] << 8 | bytes[4],\n      maxBitrate: bytes[5] << 24 | bytes[6] << 16 | bytes[7] << 8 | bytes[8],\n      avgBitrate: bytes[9] << 24 | bytes[10] << 16 | bytes[11] << 8 | bytes[12],\n      descriptors: parseDescriptors(bytes.subarray(13))\n    };\n    return desc;\n  }\n}, {\n  id: 0x05,\n  parser: function parser(bytes) {\n    // DecoderSpecificInfo\n    return {\n      tag: 0x05,\n      bytes: bytes\n    };\n  }\n}, {\n  id: 0x06,\n  parser: function parser(bytes) {\n    // SLConfigDescriptor\n    return {\n      tag: 0x06,\n      bytes: bytes\n    };\n  }\n}];\n/**\n * find any number of boxes by name given a path to it in an iso bmff\n * such as mp4.\n *\n * @param {TypedArray} bytes\n *        bytes for the iso bmff to search for boxes in\n *\n * @param {Uint8Array[]|string[]|string|Uint8Array} name\n *        An array of paths or a single path representing the name\n *        of boxes to search through in bytes. Paths may be\n *        uint8 (character codes) or strings.\n *\n * @param {boolean} [complete=false]\n *        Should we search only for complete boxes on the final path.\n *        This is very useful when you do not want to get back partial boxes\n *        in the case of streaming files.\n *\n * @return {Uint8Array[]}\n *         An array of the end paths that we found.\n */\n\nexport var findBox = function findBox(bytes, paths, complete) {\n  if (complete === void 0) {\n    complete = false;\n  }\n\n  paths = normalizePaths(paths);\n  bytes = toUint8(bytes);\n  var results = [];\n\n  if (!paths.length) {\n    // short-circuit the search for empty paths\n    return results;\n  }\n\n  var i = 0;\n\n  while (i < bytes.length) {\n    var size = (bytes[i] << 24 | bytes[i + 1] << 16 | bytes[i + 2] << 8 | bytes[i + 3]) >>> 0;\n    var type = bytes.subarray(i + 4, i + 8); // invalid box format.\n\n    if (size === 0) {\n      break;\n    }\n\n    var end = i + size;\n\n    if (end > bytes.length) {\n      // this box is bigger than the number of bytes we have\n      // and complete is set, we cannot find any more boxes.\n      if (complete) {\n        break;\n      }\n\n      end = bytes.length;\n    }\n\n    var data = bytes.subarray(i + 8, end);\n\n    if (bytesMatch(type, paths[0])) {\n      if (paths.length === 1) {\n        // this is the end of the path and we've found the box we were\n        // looking for\n        results.push(data);\n      } else {\n        // recursively search for the next box along the path\n        results.push.apply(results, findBox(data, paths.slice(1), complete));\n      }\n    }\n\n    i = end;\n  } // we've finished searching all of bytes\n\n\n  return results;\n};\n/**\n * Search for a single matching box by name in an iso bmff format like\n * mp4. This function is useful for finding codec boxes which\n * can be placed arbitrarily in sample descriptions depending\n * on the version of the file or file type.\n *\n * @param {TypedArray} bytes\n *        bytes for the iso bmff to search for boxes in\n *\n * @param {string|Uint8Array} name\n *        The name of the box to find.\n *\n * @return {Uint8Array[]}\n *         a subarray of bytes representing the name boxed we found.\n */\n\nexport var findNamedBox = function findNamedBox(bytes, name) {\n  name = normalizePath(name);\n\n  if (!name.length) {\n    // short-circuit the search for empty paths\n    return bytes.subarray(bytes.length);\n  }\n\n  var i = 0;\n\n  while (i < bytes.length) {\n    if (bytesMatch(bytes.subarray(i, i + name.length), name)) {\n      var size = (bytes[i - 4] << 24 | bytes[i - 3] << 16 | bytes[i - 2] << 8 | bytes[i - 1]) >>> 0;\n      var end = size > 1 ? i + size : bytes.byteLength;\n      return bytes.subarray(i + 4, end);\n    }\n\n    i++;\n  } // we've finished searching all of bytes\n\n\n  return bytes.subarray(bytes.length);\n};\n\nvar parseSamples = function parseSamples(data, entrySize, parseEntry) {\n  if (entrySize === void 0) {\n    entrySize = 4;\n  }\n\n  if (parseEntry === void 0) {\n    parseEntry = function parseEntry(d) {\n      return bytesToNumber(d);\n    };\n  }\n\n  var entries = [];\n\n  if (!data || !data.length) {\n    return entries;\n  }\n\n  var entryCount = bytesToNumber(data.subarray(4, 8));\n\n  for (var i = 8; entryCount; i += entrySize, entryCount--) {\n    entries.push(parseEntry(data.subarray(i, i + entrySize)));\n  }\n\n  return entries;\n};\n\nexport var buildFrameTable = function buildFrameTable(stbl, timescale) {\n  var keySamples = parseSamples(findBox(stbl, ['stss'])[0]);\n  var chunkOffsets = parseSamples(findBox(stbl, ['stco'])[0]);\n  var timeToSamples = parseSamples(findBox(stbl, ['stts'])[0], 8, function (entry) {\n    return {\n      sampleCount: bytesToNumber(entry.subarray(0, 4)),\n      sampleDelta: bytesToNumber(entry.subarray(4, 8))\n    };\n  });\n  var samplesToChunks = parseSamples(findBox(stbl, ['stsc'])[0], 12, function (entry) {\n    return {\n      firstChunk: bytesToNumber(entry.subarray(0, 4)),\n      samplesPerChunk: bytesToNumber(entry.subarray(4, 8)),\n      sampleDescriptionIndex: bytesToNumber(entry.subarray(8, 12))\n    };\n  });\n  var stsz = findBox(stbl, ['stsz'])[0]; // stsz starts with a 4 byte sampleSize which we don't need\n\n  var sampleSizes = parseSamples(stsz && stsz.length && stsz.subarray(4) || null);\n  var frames = [];\n\n  for (var chunkIndex = 0; chunkIndex < chunkOffsets.length; chunkIndex++) {\n    var samplesInChunk = void 0;\n\n    for (var i = 0; i < samplesToChunks.length; i++) {\n      var sampleToChunk = samplesToChunks[i];\n      var isThisOne = chunkIndex + 1 >= sampleToChunk.firstChunk && (i + 1 >= samplesToChunks.length || chunkIndex + 1 < samplesToChunks[i + 1].firstChunk);\n\n      if (isThisOne) {\n        samplesInChunk = sampleToChunk.samplesPerChunk;\n        break;\n      }\n    }\n\n    var chunkOffset = chunkOffsets[chunkIndex];\n\n    for (var _i = 0; _i < samplesInChunk; _i++) {\n      var frameEnd = sampleSizes[frames.length]; // if we don't have key samples every frame is a keyframe\n\n      var keyframe = !keySamples.length;\n\n      if (keySamples.length && keySamples.indexOf(frames.length + 1) !== -1) {\n        keyframe = true;\n      }\n\n      var frame = {\n        keyframe: keyframe,\n        start: chunkOffset,\n        end: chunkOffset + frameEnd\n      };\n\n      for (var k = 0; k < timeToSamples.length; k++) {\n        var _timeToSamples$k = timeToSamples[k],\n            sampleCount = _timeToSamples$k.sampleCount,\n            sampleDelta = _timeToSamples$k.sampleDelta;\n\n        if (frames.length <= sampleCount) {\n          // ms to ns\n          var lastTimestamp = frames.length ? frames[frames.length - 1].timestamp : 0;\n          frame.timestamp = lastTimestamp + sampleDelta / timescale * 1000;\n          frame.duration = sampleDelta;\n          break;\n        }\n      }\n\n      frames.push(frame);\n      chunkOffset += frameEnd;\n    }\n  }\n\n  return frames;\n};\nexport var addSampleDescription = function addSampleDescription(track, bytes) {\n  var codec = bytesToString(bytes.subarray(0, 4));\n\n  if (track.type === 'video') {\n    track.info = track.info || {};\n    track.info.width = bytes[28] << 8 | bytes[29];\n    track.info.height = bytes[30] << 8 | bytes[31];\n  } else if (track.type === 'audio') {\n    track.info = track.info || {};\n    track.info.channels = bytes[20] << 8 | bytes[21];\n    track.info.bitDepth = bytes[22] << 8 | bytes[23];\n    track.info.sampleRate = bytes[28] << 8 | bytes[29];\n  }\n\n  if (codec === 'avc1') {\n    var avcC = findNamedBox(bytes, 'avcC'); // AVCDecoderConfigurationRecord\n\n    codec += \".\" + getAvcCodec(avcC);\n    track.info.avcC = avcC; // TODO: do we need to parse all this?\n\n    /* {\n      configurationVersion: avcC[0],\n      profile: avcC[1],\n      profileCompatibility: avcC[2],\n      level: avcC[3],\n      lengthSizeMinusOne: avcC[4] & 0x3\n    };\n     let spsNalUnitCount = avcC[5] & 0x1F;\n    const spsNalUnits = track.info.avc.spsNalUnits = [];\n     // past spsNalUnitCount\n    let offset = 6;\n     while (spsNalUnitCount--) {\n      const nalLen = avcC[offset] << 8 | avcC[offset + 1];\n       spsNalUnits.push(avcC.subarray(offset + 2, offset + 2 + nalLen));\n       offset += nalLen + 2;\n    }\n    let ppsNalUnitCount = avcC[offset];\n    const ppsNalUnits = track.info.avc.ppsNalUnits = [];\n     // past ppsNalUnitCount\n    offset += 1;\n     while (ppsNalUnitCount--) {\n      const nalLen = avcC[offset] << 8 | avcC[offset + 1];\n       ppsNalUnits.push(avcC.subarray(offset + 2, offset + 2 + nalLen));\n       offset += nalLen + 2;\n    }*/\n    // HEVCDecoderConfigurationRecord\n  } else if (codec === 'hvc1' || codec === 'hev1') {\n    codec += \".\" + getHvcCodec(findNamedBox(bytes, 'hvcC'));\n  } else if (codec === 'mp4a' || codec === 'mp4v') {\n    var esds = findNamedBox(bytes, 'esds');\n    var esDescriptor = parseDescriptors(esds.subarray(4))[0];\n    var decoderConfig = esDescriptor && esDescriptor.descriptors.filter(function (_ref) {\n      var tag = _ref.tag;\n      return tag === 0x04;\n    })[0];\n\n    if (decoderConfig) {\n      // most codecs do not have a further '.'\n      // such as 0xa5 for ac-3 and 0xa6 for e-ac-3\n      codec += '.' + toHexString(decoderConfig.oti);\n\n      if (decoderConfig.oti === 0x40) {\n        codec += '.' + (decoderConfig.descriptors[0].bytes[0] >> 3).toString();\n      } else if (decoderConfig.oti === 0x20) {\n        codec += '.' + decoderConfig.descriptors[0].bytes[4].toString();\n      } else if (decoderConfig.oti === 0xdd) {\n        codec = 'vorbis';\n      }\n    } else if (track.type === 'audio') {\n      codec += '.40.2';\n    } else {\n      codec += '.20.9';\n    }\n  } else if (codec === 'av01') {\n    // AV1DecoderConfigurationRecord\n    codec += \".\" + getAv1Codec(findNamedBox(bytes, 'av1C'));\n  } else if (codec === 'vp09') {\n    // VPCodecConfigurationRecord\n    var vpcC = findNamedBox(bytes, 'vpcC'); // https://www.webmproject.org/vp9/mp4/\n\n    var profile = vpcC[0];\n    var level = vpcC[1];\n    var bitDepth = vpcC[2] >> 4;\n    var chromaSubsampling = (vpcC[2] & 0x0F) >> 1;\n    var videoFullRangeFlag = (vpcC[2] & 0x0F) >> 3;\n    var colourPrimaries = vpcC[3];\n    var transferCharacteristics = vpcC[4];\n    var matrixCoefficients = vpcC[5];\n    codec += \".\" + padStart(profile, 2, '0');\n    codec += \".\" + padStart(level, 2, '0');\n    codec += \".\" + padStart(bitDepth, 2, '0');\n    codec += \".\" + padStart(chromaSubsampling, 2, '0');\n    codec += \".\" + padStart(colourPrimaries, 2, '0');\n    codec += \".\" + padStart(transferCharacteristics, 2, '0');\n    codec += \".\" + padStart(matrixCoefficients, 2, '0');\n    codec += \".\" + padStart(videoFullRangeFlag, 2, '0');\n  } else if (codec === 'theo') {\n    codec = 'theora';\n  } else if (codec === 'spex') {\n    codec = 'speex';\n  } else if (codec === '.mp3') {\n    codec = 'mp4a.40.34';\n  } else if (codec === 'msVo') {\n    codec = 'vorbis';\n  } else if (codec === 'Opus') {\n    codec = 'opus';\n    var dOps = findNamedBox(bytes, 'dOps');\n    track.info.opus = parseOpusHead(dOps); // TODO: should this go into the webm code??\n    // Firefox requires a codecDelay for opus playback\n    // see https://bugzilla.mozilla.org/show_bug.cgi?id=1276238\n\n    track.info.codecDelay = 6500000;\n  } else {\n    codec = codec.toLowerCase();\n  }\n  /* eslint-enable */\n  // flac, ac-3, ec-3, opus\n\n\n  track.codec = codec;\n};\nexport var parseTracks = function parseTracks(bytes, frameTable) {\n  if (frameTable === void 0) {\n    frameTable = true;\n  }\n\n  bytes = toUint8(bytes);\n  var traks = findBox(bytes, ['moov', 'trak'], true);\n  var tracks = [];\n  traks.forEach(function (trak) {\n    var track = {\n      bytes: trak\n    };\n    var mdia = findBox(trak, ['mdia'])[0];\n    var hdlr = findBox(mdia, ['hdlr'])[0];\n    var trakType = bytesToString(hdlr.subarray(8, 12));\n\n    if (trakType === 'soun') {\n      track.type = 'audio';\n    } else if (trakType === 'vide') {\n      track.type = 'video';\n    } else {\n      track.type = trakType;\n    }\n\n    var tkhd = findBox(trak, ['tkhd'])[0];\n\n    if (tkhd) {\n      var view = new DataView(tkhd.buffer, tkhd.byteOffset, tkhd.byteLength);\n      var tkhdVersion = view.getUint8(0);\n      track.number = tkhdVersion === 0 ? view.getUint32(12) : view.getUint32(20);\n    }\n\n    var mdhd = findBox(mdia, ['mdhd'])[0];\n\n    if (mdhd) {\n      // mdhd is a FullBox, meaning it will have its own version as the first byte\n      var version = mdhd[0];\n      var index = version === 0 ? 12 : 20;\n      track.timescale = (mdhd[index] << 24 | mdhd[index + 1] << 16 | mdhd[index + 2] << 8 | mdhd[index + 3]) >>> 0;\n    }\n\n    var stbl = findBox(mdia, ['minf', 'stbl'])[0];\n    var stsd = findBox(stbl, ['stsd'])[0];\n    var descriptionCount = bytesToNumber(stsd.subarray(4, 8));\n    var offset = 8; // add codec and codec info\n\n    while (descriptionCount--) {\n      var len = bytesToNumber(stsd.subarray(offset, offset + 4));\n      var sampleDescriptor = stsd.subarray(offset + 4, offset + 4 + len);\n      addSampleDescription(track, sampleDescriptor);\n      offset += 4 + len;\n    }\n\n    if (frameTable) {\n      track.frameTable = buildFrameTable(stbl, track.timescale);\n    } // codec has no sub parameters\n\n\n    tracks.push(track);\n  });\n  return tracks;\n};\nexport var parseMediaInfo = function parseMediaInfo(bytes) {\n  var mvhd = findBox(bytes, ['moov', 'mvhd'], true)[0];\n\n  if (!mvhd || !mvhd.length) {\n    return;\n  }\n\n  var info = {}; // ms to ns\n  // mvhd v1 has 8 byte duration and other fields too\n\n  if (mvhd[0] === 1) {\n    info.timestampScale = bytesToNumber(mvhd.subarray(20, 24));\n    info.duration = bytesToNumber(mvhd.subarray(24, 32));\n  } else {\n    info.timestampScale = bytesToNumber(mvhd.subarray(12, 16));\n    info.duration = bytesToNumber(mvhd.subarray(16, 20));\n  }\n\n  info.bytes = mvhd;\n  return info;\n};"],"mappings":"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"},"metadata":{},"sourceType":"module"}