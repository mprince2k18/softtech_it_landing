{"ast":null,"code":"import \"core-js/modules/es.error.cause.js\";\n\n/*! @name mpd-parser @version 0.21.1 @license Apache-2.0 */\nimport resolveUrl from '@videojs/vhs-utils/es/resolve-url';\nimport window from 'global/window';\nimport { forEachMediaGroup } from '@videojs/vhs-utils/es/media-groups';\nimport decodeB64ToUint8Array from '@videojs/vhs-utils/es/decode-b64-to-uint8-array';\nimport { DOMParser } from '@xmldom/xmldom';\nvar version = \"0.21.1\";\n\nvar isObject = function isObject(obj) {\n  return !!obj && typeof obj === 'object';\n};\n\nvar merge = function merge() {\n  for (var _len = arguments.length, objects = new Array(_len), _key = 0; _key < _len; _key++) {\n    objects[_key] = arguments[_key];\n  }\n\n  return objects.reduce(function (result, source) {\n    if (typeof source !== 'object') {\n      return result;\n    }\n\n    Object.keys(source).forEach(function (key) {\n      if (Array.isArray(result[key]) && Array.isArray(source[key])) {\n        result[key] = result[key].concat(source[key]);\n      } else if (isObject(result[key]) && isObject(source[key])) {\n        result[key] = merge(result[key], source[key]);\n      } else {\n        result[key] = source[key];\n      }\n    });\n    return result;\n  }, {});\n};\n\nvar values = function values(o) {\n  return Object.keys(o).map(function (k) {\n    return o[k];\n  });\n};\n\nvar range = function range(start, end) {\n  var result = [];\n\n  for (var i = start; i < end; i++) {\n    result.push(i);\n  }\n\n  return result;\n};\n\nvar flatten = function flatten(lists) {\n  return lists.reduce(function (x, y) {\n    return x.concat(y);\n  }, []);\n};\n\nvar from = function from(list) {\n  if (!list.length) {\n    return [];\n  }\n\n  var result = [];\n\n  for (var i = 0; i < list.length; i++) {\n    result.push(list[i]);\n  }\n\n  return result;\n};\n\nvar findIndexes = function findIndexes(l, key) {\n  return l.reduce(function (a, e, i) {\n    if (e[key]) {\n      a.push(i);\n    }\n\n    return a;\n  }, []);\n};\n/**\n * Returns the first index that satisfies the matching function, or -1 if not found.\n *\n * Only necessary because of IE11 support.\n *\n * @param {Array} list - the list to search through\n * @param {Function} matchingFunction - the matching function\n *\n * @return {number} the matching index or -1 if not found\n */\n\n\nvar findIndex = function findIndex(list, matchingFunction) {\n  for (var i = 0; i < list.length; i++) {\n    if (matchingFunction(list[i])) {\n      return i;\n    }\n  }\n\n  return -1;\n};\n/**\n * Returns a union of the included lists provided each element can be identified by a key.\n *\n * @param {Array} list - list of lists to get the union of\n * @param {Function} keyFunction - the function to use as a key for each element\n *\n * @return {Array} the union of the arrays\n */\n\n\nvar union = function union(lists, keyFunction) {\n  return values(lists.reduce(function (acc, list) {\n    list.forEach(function (el) {\n      acc[keyFunction(el)] = el;\n    });\n    return acc;\n  }, {}));\n};\n\nvar errors = {\n  INVALID_NUMBER_OF_PERIOD: 'INVALID_NUMBER_OF_PERIOD',\n  DASH_EMPTY_MANIFEST: 'DASH_EMPTY_MANIFEST',\n  DASH_INVALID_XML: 'DASH_INVALID_XML',\n  NO_BASE_URL: 'NO_BASE_URL',\n  MISSING_SEGMENT_INFORMATION: 'MISSING_SEGMENT_INFORMATION',\n  SEGMENT_TIME_UNSPECIFIED: 'SEGMENT_TIME_UNSPECIFIED',\n  UNSUPPORTED_UTC_TIMING_SCHEME: 'UNSUPPORTED_UTC_TIMING_SCHEME'\n};\n/**\n * @typedef {Object} SingleUri\n * @property {string} uri - relative location of segment\n * @property {string} resolvedUri - resolved location of segment\n * @property {Object} byterange - Object containing information on how to make byte range\n *   requests following byte-range-spec per RFC2616.\n * @property {String} byterange.length - length of range request\n * @property {String} byterange.offset - byte offset of range request\n *\n * @see https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.35.1\n */\n\n/**\n * Converts a URLType node (5.3.9.2.3 Table 13) to a segment object\n * that conforms to how m3u8-parser is structured\n *\n * @see https://github.com/videojs/m3u8-parser\n *\n * @param {string} baseUrl - baseUrl provided by <BaseUrl> nodes\n * @param {string} source - source url for segment\n * @param {string} range - optional range used for range calls,\n *   follows  RFC 2616, Clause 14.35.1\n * @return {SingleUri} full segment information transformed into a format similar\n *   to m3u8-parser\n */\n\nvar urlTypeToSegment = function urlTypeToSegment(_ref) {\n  var _ref$baseUrl = _ref.baseUrl,\n      baseUrl = _ref$baseUrl === void 0 ? '' : _ref$baseUrl,\n      _ref$source = _ref.source,\n      source = _ref$source === void 0 ? '' : _ref$source,\n      _ref$range = _ref.range,\n      range = _ref$range === void 0 ? '' : _ref$range,\n      _ref$indexRange = _ref.indexRange,\n      indexRange = _ref$indexRange === void 0 ? '' : _ref$indexRange;\n  var segment = {\n    uri: source,\n    resolvedUri: resolveUrl(baseUrl || '', source)\n  };\n\n  if (range || indexRange) {\n    var rangeStr = range ? range : indexRange;\n    var ranges = rangeStr.split('-'); // default to parsing this as a BigInt if possible\n\n    var startRange = window.BigInt ? window.BigInt(ranges[0]) : parseInt(ranges[0], 10);\n    var endRange = window.BigInt ? window.BigInt(ranges[1]) : parseInt(ranges[1], 10); // convert back to a number if less than MAX_SAFE_INTEGER\n\n    if (startRange < Number.MAX_SAFE_INTEGER && typeof startRange === 'bigint') {\n      startRange = Number(startRange);\n    }\n\n    if (endRange < Number.MAX_SAFE_INTEGER && typeof endRange === 'bigint') {\n      endRange = Number(endRange);\n    }\n\n    var length;\n\n    if (typeof endRange === 'bigint' || typeof startRange === 'bigint') {\n      length = window.BigInt(endRange) - window.BigInt(startRange) + window.BigInt(1);\n    } else {\n      length = endRange - startRange + 1;\n    }\n\n    if (typeof length === 'bigint' && length < Number.MAX_SAFE_INTEGER) {\n      length = Number(length);\n    } // byterange should be inclusive according to\n    // RFC 2616, Clause 14.35.1\n\n\n    segment.byterange = {\n      length: length,\n      offset: startRange\n    };\n  }\n\n  return segment;\n};\n\nvar byteRangeToString = function byteRangeToString(byterange) {\n  // `endRange` is one less than `offset + length` because the HTTP range\n  // header uses inclusive ranges\n  var endRange;\n\n  if (typeof byterange.offset === 'bigint' || typeof byterange.length === 'bigint') {\n    endRange = window.BigInt(byterange.offset) + window.BigInt(byterange.length) - window.BigInt(1);\n  } else {\n    endRange = byterange.offset + byterange.length - 1;\n  }\n\n  return byterange.offset + \"-\" + endRange;\n};\n/**\n * parse the end number attribue that can be a string\n * number, or undefined.\n *\n * @param {string|number|undefined} endNumber\n *        The end number attribute.\n *\n * @return {number|null}\n *          The result of parsing the end number.\n */\n\n\nvar parseEndNumber = function parseEndNumber(endNumber) {\n  if (endNumber && typeof endNumber !== 'number') {\n    endNumber = parseInt(endNumber, 10);\n  }\n\n  if (isNaN(endNumber)) {\n    return null;\n  }\n\n  return endNumber;\n};\n/**\n * Functions for calculating the range of available segments in static and dynamic\n * manifests.\n */\n\n\nvar segmentRange = {\n  /**\n   * Returns the entire range of available segments for a static MPD\n   *\n   * @param {Object} attributes\n   *        Inheritied MPD attributes\n   * @return {{ start: number, end: number }}\n   *         The start and end numbers for available segments\n   */\n  static: function _static(attributes) {\n    var duration = attributes.duration,\n        _attributes$timescale = attributes.timescale,\n        timescale = _attributes$timescale === void 0 ? 1 : _attributes$timescale,\n        sourceDuration = attributes.sourceDuration,\n        periodDuration = attributes.periodDuration;\n    var endNumber = parseEndNumber(attributes.endNumber);\n    var segmentDuration = duration / timescale;\n\n    if (typeof endNumber === 'number') {\n      return {\n        start: 0,\n        end: endNumber\n      };\n    }\n\n    if (typeof periodDuration === 'number') {\n      return {\n        start: 0,\n        end: periodDuration / segmentDuration\n      };\n    }\n\n    return {\n      start: 0,\n      end: sourceDuration / segmentDuration\n    };\n  },\n\n  /**\n   * Returns the current live window range of available segments for a dynamic MPD\n   *\n   * @param {Object} attributes\n   *        Inheritied MPD attributes\n   * @return {{ start: number, end: number }}\n   *         The start and end numbers for available segments\n   */\n  dynamic: function dynamic(attributes) {\n    var NOW = attributes.NOW,\n        clientOffset = attributes.clientOffset,\n        availabilityStartTime = attributes.availabilityStartTime,\n        _attributes$timescale2 = attributes.timescale,\n        timescale = _attributes$timescale2 === void 0 ? 1 : _attributes$timescale2,\n        duration = attributes.duration,\n        _attributes$periodSta = attributes.periodStart,\n        periodStart = _attributes$periodSta === void 0 ? 0 : _attributes$periodSta,\n        _attributes$minimumUp = attributes.minimumUpdatePeriod,\n        minimumUpdatePeriod = _attributes$minimumUp === void 0 ? 0 : _attributes$minimumUp,\n        _attributes$timeShift = attributes.timeShiftBufferDepth,\n        timeShiftBufferDepth = _attributes$timeShift === void 0 ? Infinity : _attributes$timeShift;\n    var endNumber = parseEndNumber(attributes.endNumber); // clientOffset is passed in at the top level of mpd-parser and is an offset calculated\n    // after retrieving UTC server time.\n\n    var now = (NOW + clientOffset) / 1000; // WC stands for Wall Clock.\n    // Convert the period start time to EPOCH.\n\n    var periodStartWC = availabilityStartTime + periodStart; // Period end in EPOCH is manifest's retrieval time + time until next update.\n\n    var periodEndWC = now + minimumUpdatePeriod;\n    var periodDuration = periodEndWC - periodStartWC;\n    var segmentCount = Math.ceil(periodDuration * timescale / duration);\n    var availableStart = Math.floor((now - periodStartWC - timeShiftBufferDepth) * timescale / duration);\n    var availableEnd = Math.floor((now - periodStartWC) * timescale / duration);\n    return {\n      start: Math.max(0, availableStart),\n      end: typeof endNumber === 'number' ? endNumber : Math.min(segmentCount, availableEnd)\n    };\n  }\n};\n/**\n * Maps a range of numbers to objects with information needed to build the corresponding\n * segment list\n *\n * @name toSegmentsCallback\n * @function\n * @param {number} number\n *        Number of the segment\n * @param {number} index\n *        Index of the number in the range list\n * @return {{ number: Number, duration: Number, timeline: Number, time: Number }}\n *         Object with segment timing and duration info\n */\n\n/**\n * Returns a callback for Array.prototype.map for mapping a range of numbers to\n * information needed to build the segment list.\n *\n * @param {Object} attributes\n *        Inherited MPD attributes\n * @return {toSegmentsCallback}\n *         Callback map function\n */\n\nvar toSegments = function toSegments(attributes) {\n  return function (number) {\n    var duration = attributes.duration,\n        _attributes$timescale3 = attributes.timescale,\n        timescale = _attributes$timescale3 === void 0 ? 1 : _attributes$timescale3,\n        periodStart = attributes.periodStart,\n        _attributes$startNumb = attributes.startNumber,\n        startNumber = _attributes$startNumb === void 0 ? 1 : _attributes$startNumb;\n    return {\n      number: startNumber + number,\n      duration: duration / timescale,\n      timeline: periodStart,\n      time: number * duration\n    };\n  };\n};\n/**\n * Returns a list of objects containing segment timing and duration info used for\n * building the list of segments. This uses the @duration attribute specified\n * in the MPD manifest to derive the range of segments.\n *\n * @param {Object} attributes\n *        Inherited MPD attributes\n * @return {{number: number, duration: number, time: number, timeline: number}[]}\n *         List of Objects with segment timing and duration info\n */\n\n\nvar parseByDuration = function parseByDuration(attributes) {\n  var type = attributes.type,\n      duration = attributes.duration,\n      _attributes$timescale4 = attributes.timescale,\n      timescale = _attributes$timescale4 === void 0 ? 1 : _attributes$timescale4,\n      periodDuration = attributes.periodDuration,\n      sourceDuration = attributes.sourceDuration;\n\n  var _segmentRange$type = segmentRange[type](attributes),\n      start = _segmentRange$type.start,\n      end = _segmentRange$type.end;\n\n  var segments = range(start, end).map(toSegments(attributes));\n\n  if (type === 'static') {\n    var index = segments.length - 1; // section is either a period or the full source\n\n    var sectionDuration = typeof periodDuration === 'number' ? periodDuration : sourceDuration; // final segment may be less than full segment duration\n\n    segments[index].duration = sectionDuration - duration / timescale * index;\n  }\n\n  return segments;\n};\n/**\n * Translates SegmentBase into a set of segments.\n * (DASH SPEC Section 5.3.9.3.2) contains a set of <SegmentURL> nodes.  Each\n * node should be translated into segment.\n *\n * @param {Object} attributes\n *   Object containing all inherited attributes from parent elements with attribute\n *   names as keys\n * @return {Object.<Array>} list of segments\n */\n\n\nvar segmentsFromBase = function segmentsFromBase(attributes) {\n  var baseUrl = attributes.baseUrl,\n      _attributes$initializ = attributes.initialization,\n      initialization = _attributes$initializ === void 0 ? {} : _attributes$initializ,\n      sourceDuration = attributes.sourceDuration,\n      _attributes$indexRang = attributes.indexRange,\n      indexRange = _attributes$indexRang === void 0 ? '' : _attributes$indexRang,\n      periodStart = attributes.periodStart,\n      presentationTime = attributes.presentationTime,\n      _attributes$number = attributes.number,\n      number = _attributes$number === void 0 ? 0 : _attributes$number,\n      duration = attributes.duration; // base url is required for SegmentBase to work, per spec (Section 5.3.9.2.1)\n\n  if (!baseUrl) {\n    throw new Error(errors.NO_BASE_URL);\n  }\n\n  var initSegment = urlTypeToSegment({\n    baseUrl: baseUrl,\n    source: initialization.sourceURL,\n    range: initialization.range\n  });\n  var segment = urlTypeToSegment({\n    baseUrl: baseUrl,\n    source: baseUrl,\n    indexRange: indexRange\n  });\n  segment.map = initSegment; // If there is a duration, use it, otherwise use the given duration of the source\n  // (since SegmentBase is only for one total segment)\n\n  if (duration) {\n    var segmentTimeInfo = parseByDuration(attributes);\n\n    if (segmentTimeInfo.length) {\n      segment.duration = segmentTimeInfo[0].duration;\n      segment.timeline = segmentTimeInfo[0].timeline;\n    }\n  } else if (sourceDuration) {\n    segment.duration = sourceDuration;\n    segment.timeline = periodStart;\n  } // If presentation time is provided, these segments are being generated by SIDX\n  // references, and should use the time provided. For the general case of SegmentBase,\n  // there should only be one segment in the period, so its presentation time is the same\n  // as its period start.\n\n\n  segment.presentationTime = presentationTime || periodStart;\n  segment.number = number;\n  return [segment];\n};\n/**\n * Given a playlist, a sidx box, and a baseUrl, update the segment list of the playlist\n * according to the sidx information given.\n *\n * playlist.sidx has metadadata about the sidx where-as the sidx param\n * is the parsed sidx box itself.\n *\n * @param {Object} playlist the playlist to update the sidx information for\n * @param {Object} sidx the parsed sidx box\n * @return {Object} the playlist object with the updated sidx information\n */\n\n\nvar addSidxSegmentsToPlaylist$1 = function addSidxSegmentsToPlaylist(playlist, sidx, baseUrl) {\n  // Retain init segment information\n  var initSegment = playlist.sidx.map ? playlist.sidx.map : null; // Retain source duration from initial main manifest parsing\n\n  var sourceDuration = playlist.sidx.duration; // Retain source timeline\n\n  var timeline = playlist.timeline || 0;\n  var sidxByteRange = playlist.sidx.byterange;\n  var sidxEnd = sidxByteRange.offset + sidxByteRange.length; // Retain timescale of the parsed sidx\n\n  var timescale = sidx.timescale; // referenceType 1 refers to other sidx boxes\n\n  var mediaReferences = sidx.references.filter(function (r) {\n    return r.referenceType !== 1;\n  });\n  var segments = [];\n  var type = playlist.endList ? 'static' : 'dynamic';\n  var periodStart = playlist.sidx.timeline;\n  var presentationTime = periodStart;\n  var number = playlist.mediaSequence || 0; // firstOffset is the offset from the end of the sidx box\n\n  var startIndex; // eslint-disable-next-line\n\n  if (typeof sidx.firstOffset === 'bigint') {\n    startIndex = window.BigInt(sidxEnd) + sidx.firstOffset;\n  } else {\n    startIndex = sidxEnd + sidx.firstOffset;\n  }\n\n  for (var i = 0; i < mediaReferences.length; i++) {\n    var reference = sidx.references[i]; // size of the referenced (sub)segment\n\n    var size = reference.referencedSize; // duration of the referenced (sub)segment, in  the  timescale\n    // this will be converted to seconds when generating segments\n\n    var duration = reference.subsegmentDuration; // should be an inclusive range\n\n    var endIndex = void 0; // eslint-disable-next-line\n\n    if (typeof startIndex === 'bigint') {\n      endIndex = startIndex + window.BigInt(size) - window.BigInt(1);\n    } else {\n      endIndex = startIndex + size - 1;\n    }\n\n    var indexRange = startIndex + \"-\" + endIndex;\n    var attributes = {\n      baseUrl: baseUrl,\n      timescale: timescale,\n      timeline: timeline,\n      periodStart: periodStart,\n      presentationTime: presentationTime,\n      number: number,\n      duration: duration,\n      sourceDuration: sourceDuration,\n      indexRange: indexRange,\n      type: type\n    };\n    var segment = segmentsFromBase(attributes)[0];\n\n    if (initSegment) {\n      segment.map = initSegment;\n    }\n\n    segments.push(segment);\n\n    if (typeof startIndex === 'bigint') {\n      startIndex += window.BigInt(size);\n    } else {\n      startIndex += size;\n    }\n\n    presentationTime += duration / timescale;\n    number++;\n  }\n\n  playlist.segments = segments;\n  return playlist;\n};\n\nvar SUPPORTED_MEDIA_TYPES = ['AUDIO', 'SUBTITLES']; // allow one 60fps frame as leniency (arbitrarily chosen)\n\nvar TIME_FUDGE = 1 / 60;\n/**\n * Given a list of timelineStarts, combines, dedupes, and sorts them.\n *\n * @param {TimelineStart[]} timelineStarts - list of timeline starts\n *\n * @return {TimelineStart[]} the combined and deduped timeline starts\n */\n\nvar getUniqueTimelineStarts = function getUniqueTimelineStarts(timelineStarts) {\n  return union(timelineStarts, function (_ref) {\n    var timeline = _ref.timeline;\n    return timeline;\n  }).sort(function (a, b) {\n    return a.timeline > b.timeline ? 1 : -1;\n  });\n};\n/**\n * Finds the playlist with the matching NAME attribute.\n *\n * @param {Array} playlists - playlists to search through\n * @param {string} name - the NAME attribute to search for\n *\n * @return {Object|null} the matching playlist object, or null\n */\n\n\nvar findPlaylistWithName = function findPlaylistWithName(playlists, name) {\n  for (var i = 0; i < playlists.length; i++) {\n    if (playlists[i].attributes.NAME === name) {\n      return playlists[i];\n    }\n  }\n\n  return null;\n};\n/**\n * Gets a flattened array of media group playlists.\n *\n * @param {Object} manifest - the main manifest object\n *\n * @return {Array} the media group playlists\n */\n\n\nvar getMediaGroupPlaylists = function getMediaGroupPlaylists(manifest) {\n  var mediaGroupPlaylists = [];\n  forEachMediaGroup(manifest, SUPPORTED_MEDIA_TYPES, function (properties, type, group, label) {\n    mediaGroupPlaylists = mediaGroupPlaylists.concat(properties.playlists || []);\n  });\n  return mediaGroupPlaylists;\n};\n/**\n * Updates the playlist's media sequence numbers.\n *\n * @param {Object} config - options object\n * @param {Object} config.playlist - the playlist to update\n * @param {number} config.mediaSequence - the mediaSequence number to start with\n */\n\n\nvar updateMediaSequenceForPlaylist = function updateMediaSequenceForPlaylist(_ref2) {\n  var playlist = _ref2.playlist,\n      mediaSequence = _ref2.mediaSequence;\n  playlist.mediaSequence = mediaSequence;\n  playlist.segments.forEach(function (segment, index) {\n    segment.number = playlist.mediaSequence + index;\n  });\n};\n/**\n * Updates the media and discontinuity sequence numbers of newPlaylists given oldPlaylists\n * and a complete list of timeline starts.\n *\n * If no matching playlist is found, only the discontinuity sequence number of the playlist\n * will be updated.\n *\n * Since early available timelines are not supported, at least one segment must be present.\n *\n * @param {Object} config - options object\n * @param {Object[]} oldPlaylists - the old playlists to use as a reference\n * @param {Object[]} newPlaylists - the new playlists to update\n * @param {Object} timelineStarts - all timelineStarts seen in the stream to this point\n */\n\n\nvar updateSequenceNumbers = function updateSequenceNumbers(_ref3) {\n  var oldPlaylists = _ref3.oldPlaylists,\n      newPlaylists = _ref3.newPlaylists,\n      timelineStarts = _ref3.timelineStarts;\n  newPlaylists.forEach(function (playlist) {\n    playlist.discontinuitySequence = findIndex(timelineStarts, function (_ref4) {\n      var timeline = _ref4.timeline;\n      return timeline === playlist.timeline;\n    }); // Playlists NAMEs come from DASH Representation IDs, which are mandatory\n    // (see ISO_23009-1-2012 5.3.5.2).\n    //\n    // If the same Representation existed in a prior Period, it will retain the same NAME.\n\n    var oldPlaylist = findPlaylistWithName(oldPlaylists, playlist.attributes.NAME);\n\n    if (!oldPlaylist) {\n      // Since this is a new playlist, the media sequence values can start from 0 without\n      // consequence.\n      return;\n    } // TODO better support for live SIDX\n    //\n    // As of this writing, mpd-parser does not support multiperiod SIDX (in live or VOD).\n    // This is evident by a playlist only having a single SIDX reference. In a multiperiod\n    // playlist there would need to be multiple SIDX references. In addition, live SIDX is\n    // not supported when the SIDX properties change on refreshes.\n    //\n    // In the future, if support needs to be added, the merging logic here can be called\n    // after SIDX references are resolved. For now, exit early to prevent exceptions being\n    // thrown due to undefined references.\n\n\n    if (playlist.sidx) {\n      return;\n    } // Since we don't yet support early available timelines, we don't need to support\n    // playlists with no segments.\n\n\n    var firstNewSegment = playlist.segments[0];\n    var oldMatchingSegmentIndex = findIndex(oldPlaylist.segments, function (oldSegment) {\n      return Math.abs(oldSegment.presentationTime - firstNewSegment.presentationTime) < TIME_FUDGE;\n    }); // No matching segment from the old playlist means the entire playlist was refreshed.\n    // In this case the media sequence should account for this update, and the new segments\n    // should be marked as discontinuous from the prior content, since the last prior\n    // timeline was removed.\n\n    if (oldMatchingSegmentIndex === -1) {\n      updateMediaSequenceForPlaylist({\n        playlist: playlist,\n        mediaSequence: oldPlaylist.mediaSequence + oldPlaylist.segments.length\n      });\n      playlist.segments[0].discontinuity = true;\n      playlist.discontinuityStarts.unshift(0); // No matching segment does not necessarily mean there's missing content.\n      //\n      // If the new playlist's timeline is the same as the last seen segment's timeline,\n      // then a discontinuity can be added to identify that there's potentially missing\n      // content. If there's no missing content, the discontinuity should still be rather\n      // harmless. It's possible that if segment durations are accurate enough, that the\n      // existence of a gap can be determined using the presentation times and durations,\n      // but if the segment timing info is off, it may introduce more problems than simply\n      // adding the discontinuity.\n      //\n      // If the new playlist's timeline is different from the last seen segment's timeline,\n      // then a discontinuity can be added to identify that this is the first seen segment\n      // of a new timeline. However, the logic at the start of this function that\n      // determined the disconinuity sequence by timeline index is now off by one (the\n      // discontinuity of the newest timeline hasn't yet fallen off the manifest...since\n      // we added it), so the disconinuity sequence must be decremented.\n      //\n      // A period may also have a duration of zero, so the case of no segments is handled\n      // here even though we don't yet support early available periods.\n\n      if (!oldPlaylist.segments.length && playlist.timeline > oldPlaylist.timeline || oldPlaylist.segments.length && playlist.timeline > oldPlaylist.segments[oldPlaylist.segments.length - 1].timeline) {\n        playlist.discontinuitySequence--;\n      }\n\n      return;\n    } // If the first segment matched with a prior segment on a discontinuity (it's matching\n    // on the first segment of a period), then the discontinuitySequence shouldn't be the\n    // timeline's matching one, but instead should be the one prior, and the first segment\n    // of the new manifest should be marked with a discontinuity.\n    //\n    // The reason for this special case is that discontinuity sequence shows how many\n    // discontinuities have fallen off of the playlist, and discontinuities are marked on\n    // the first segment of a new \"timeline.\" Because of this, while DASH will retain that\n    // Period while the \"timeline\" exists, HLS keeps track of it via the discontinuity\n    // sequence, and that first segment is an indicator, but can be removed before that\n    // timeline is gone.\n\n\n    var oldMatchingSegment = oldPlaylist.segments[oldMatchingSegmentIndex];\n\n    if (oldMatchingSegment.discontinuity && !firstNewSegment.discontinuity) {\n      firstNewSegment.discontinuity = true;\n      playlist.discontinuityStarts.unshift(0);\n      playlist.discontinuitySequence--;\n    }\n\n    updateMediaSequenceForPlaylist({\n      playlist: playlist,\n      mediaSequence: oldPlaylist.segments[oldMatchingSegmentIndex].number\n    });\n  });\n};\n/**\n * Given an old parsed manifest object and a new parsed manifest object, updates the\n * sequence and timing values within the new manifest to ensure that it lines up with the\n * old.\n *\n * @param {Array} oldManifest - the old main manifest object\n * @param {Array} newManifest - the new main manifest object\n *\n * @return {Object} the updated new manifest object\n */\n\n\nvar positionManifestOnTimeline = function positionManifestOnTimeline(_ref5) {\n  var oldManifest = _ref5.oldManifest,\n      newManifest = _ref5.newManifest; // Starting from v4.1.2 of the IOP, section 4.4.3.3 states:\n  //\n  // \"MPD@availabilityStartTime and Period@start shall not be changed over MPD updates.\"\n  //\n  // This was added from https://github.com/Dash-Industry-Forum/DASH-IF-IOP/issues/160\n  //\n  // Because of this change, and the difficulty of supporting periods with changing start\n  // times, periods with changing start times are not supported. This makes the logic much\n  // simpler, since periods with the same start time can be considerred the same period\n  // across refreshes.\n  //\n  // To give an example as to the difficulty of handling periods where the start time may\n  // change, if a single period manifest is refreshed with another manifest with a single\n  // period, and both the start and end times are increased, then the only way to determine\n  // if it's a new period or an old one that has changed is to look through the segments of\n  // each playlist and determine the presentation time bounds to find a match. In addition,\n  // if the period start changed to exceed the old period end, then there would be no\n  // match, and it would not be possible to determine whether the refreshed period is a new\n  // one or the old one.\n\n  var oldPlaylists = oldManifest.playlists.concat(getMediaGroupPlaylists(oldManifest));\n  var newPlaylists = newManifest.playlists.concat(getMediaGroupPlaylists(newManifest)); // Save all seen timelineStarts to the new manifest. Although this potentially means that\n  // there's a \"memory leak\" in that it will never stop growing, in reality, only a couple\n  // of properties are saved for each seen Period. Even long running live streams won't\n  // generate too many Periods, unless the stream is watched for decades. In the future,\n  // this can be optimized by mapping to discontinuity sequence numbers for each timeline,\n  // but it may not become an issue, and the additional info can be useful for debugging.\n\n  newManifest.timelineStarts = getUniqueTimelineStarts([oldManifest.timelineStarts, newManifest.timelineStarts]);\n  updateSequenceNumbers({\n    oldPlaylists: oldPlaylists,\n    newPlaylists: newPlaylists,\n    timelineStarts: newManifest.timelineStarts\n  });\n  return newManifest;\n};\n\nvar generateSidxKey = function generateSidxKey(sidx) {\n  return sidx && sidx.uri + '-' + byteRangeToString(sidx.byterange);\n};\n\nvar mergeDiscontiguousPlaylists = function mergeDiscontiguousPlaylists(playlists) {\n  var mergedPlaylists = values(playlists.reduce(function (acc, playlist) {\n    // assuming playlist IDs are the same across periods\n    // TODO: handle multiperiod where representation sets are not the same\n    // across periods\n    var name = playlist.attributes.id + (playlist.attributes.lang || '');\n\n    if (!acc[name]) {\n      // First Period\n      acc[name] = playlist;\n      acc[name].attributes.timelineStarts = [];\n    } else {\n      // Subsequent Periods\n      if (playlist.segments) {\n        var _acc$name$segments; // first segment of subsequent periods signal a discontinuity\n\n\n        if (playlist.segments[0]) {\n          playlist.segments[0].discontinuity = true;\n        }\n\n        (_acc$name$segments = acc[name].segments).push.apply(_acc$name$segments, playlist.segments);\n      } // bubble up contentProtection, this assumes all DRM content\n      // has the same contentProtection\n\n\n      if (playlist.attributes.contentProtection) {\n        acc[name].attributes.contentProtection = playlist.attributes.contentProtection;\n      }\n    }\n\n    acc[name].attributes.timelineStarts.push({\n      // Although they represent the same number, it's important to have both to make it\n      // compatible with HLS potentially having a similar attribute.\n      start: playlist.attributes.periodStart,\n      timeline: playlist.attributes.periodStart\n    });\n    return acc;\n  }, {}));\n  return mergedPlaylists.map(function (playlist) {\n    playlist.discontinuityStarts = findIndexes(playlist.segments || [], 'discontinuity');\n    return playlist;\n  });\n};\n\nvar addSidxSegmentsToPlaylist = function addSidxSegmentsToPlaylist(playlist, sidxMapping) {\n  var sidxKey = generateSidxKey(playlist.sidx);\n  var sidxMatch = sidxKey && sidxMapping[sidxKey] && sidxMapping[sidxKey].sidx;\n\n  if (sidxMatch) {\n    addSidxSegmentsToPlaylist$1(playlist, sidxMatch, playlist.sidx.resolvedUri);\n  }\n\n  return playlist;\n};\n\nvar addSidxSegmentsToPlaylists = function addSidxSegmentsToPlaylists(playlists, sidxMapping) {\n  if (sidxMapping === void 0) {\n    sidxMapping = {};\n  }\n\n  if (!Object.keys(sidxMapping).length) {\n    return playlists;\n  }\n\n  for (var i in playlists) {\n    playlists[i] = addSidxSegmentsToPlaylist(playlists[i], sidxMapping);\n  }\n\n  return playlists;\n};\n\nvar formatAudioPlaylist = function formatAudioPlaylist(_ref, isAudioOnly) {\n  var _attributes;\n\n  var attributes = _ref.attributes,\n      segments = _ref.segments,\n      sidx = _ref.sidx,\n      mediaSequence = _ref.mediaSequence,\n      discontinuitySequence = _ref.discontinuitySequence,\n      discontinuityStarts = _ref.discontinuityStarts;\n  var playlist = {\n    attributes: (_attributes = {\n      NAME: attributes.id,\n      BANDWIDTH: attributes.bandwidth,\n      CODECS: attributes.codecs\n    }, _attributes['PROGRAM-ID'] = 1, _attributes),\n    uri: '',\n    endList: attributes.type === 'static',\n    timeline: attributes.periodStart,\n    resolvedUri: '',\n    targetDuration: attributes.duration,\n    discontinuitySequence: discontinuitySequence,\n    discontinuityStarts: discontinuityStarts,\n    timelineStarts: attributes.timelineStarts,\n    mediaSequence: mediaSequence,\n    segments: segments\n  };\n\n  if (attributes.contentProtection) {\n    playlist.contentProtection = attributes.contentProtection;\n  }\n\n  if (sidx) {\n    playlist.sidx = sidx;\n  }\n\n  if (isAudioOnly) {\n    playlist.attributes.AUDIO = 'audio';\n    playlist.attributes.SUBTITLES = 'subs';\n  }\n\n  return playlist;\n};\n\nvar formatVttPlaylist = function formatVttPlaylist(_ref2) {\n  var _m3u8Attributes;\n\n  var attributes = _ref2.attributes,\n      segments = _ref2.segments,\n      mediaSequence = _ref2.mediaSequence,\n      discontinuityStarts = _ref2.discontinuityStarts,\n      discontinuitySequence = _ref2.discontinuitySequence;\n\n  if (typeof segments === 'undefined') {\n    // vtt tracks may use single file in BaseURL\n    segments = [{\n      uri: attributes.baseUrl,\n      timeline: attributes.periodStart,\n      resolvedUri: attributes.baseUrl || '',\n      duration: attributes.sourceDuration,\n      number: 0\n    }]; // targetDuration should be the same duration as the only segment\n\n    attributes.duration = attributes.sourceDuration;\n  }\n\n  var m3u8Attributes = (_m3u8Attributes = {\n    NAME: attributes.id,\n    BANDWIDTH: attributes.bandwidth\n  }, _m3u8Attributes['PROGRAM-ID'] = 1, _m3u8Attributes);\n\n  if (attributes.codecs) {\n    m3u8Attributes.CODECS = attributes.codecs;\n  }\n\n  return {\n    attributes: m3u8Attributes,\n    uri: '',\n    endList: attributes.type === 'static',\n    timeline: attributes.periodStart,\n    resolvedUri: attributes.baseUrl || '',\n    targetDuration: attributes.duration,\n    timelineStarts: attributes.timelineStarts,\n    discontinuityStarts: discontinuityStarts,\n    discontinuitySequence: discontinuitySequence,\n    mediaSequence: mediaSequence,\n    segments: segments\n  };\n};\n\nvar organizeAudioPlaylists = function organizeAudioPlaylists(playlists, sidxMapping, isAudioOnly) {\n  if (sidxMapping === void 0) {\n    sidxMapping = {};\n  }\n\n  if (isAudioOnly === void 0) {\n    isAudioOnly = false;\n  }\n\n  var mainPlaylist;\n  var formattedPlaylists = playlists.reduce(function (a, playlist) {\n    var role = playlist.attributes.role && playlist.attributes.role.value || '';\n    var language = playlist.attributes.lang || '';\n    var label = playlist.attributes.label || 'main';\n\n    if (language && !playlist.attributes.label) {\n      var roleLabel = role ? \" (\" + role + \")\" : '';\n      label = \"\" + playlist.attributes.lang + roleLabel;\n    }\n\n    if (!a[label]) {\n      a[label] = {\n        language: language,\n        autoselect: true,\n        default: role === 'main',\n        playlists: [],\n        uri: ''\n      };\n    }\n\n    var formatted = addSidxSegmentsToPlaylist(formatAudioPlaylist(playlist, isAudioOnly), sidxMapping);\n    a[label].playlists.push(formatted);\n\n    if (typeof mainPlaylist === 'undefined' && role === 'main') {\n      mainPlaylist = playlist;\n      mainPlaylist.default = true;\n    }\n\n    return a;\n  }, {}); // if no playlists have role \"main\", mark the first as main\n\n  if (!mainPlaylist) {\n    var firstLabel = Object.keys(formattedPlaylists)[0];\n    formattedPlaylists[firstLabel].default = true;\n  }\n\n  return formattedPlaylists;\n};\n\nvar organizeVttPlaylists = function organizeVttPlaylists(playlists, sidxMapping) {\n  if (sidxMapping === void 0) {\n    sidxMapping = {};\n  }\n\n  return playlists.reduce(function (a, playlist) {\n    var label = playlist.attributes.lang || 'text';\n\n    if (!a[label]) {\n      a[label] = {\n        language: label,\n        default: false,\n        autoselect: false,\n        playlists: [],\n        uri: ''\n      };\n    }\n\n    a[label].playlists.push(addSidxSegmentsToPlaylist(formatVttPlaylist(playlist), sidxMapping));\n    return a;\n  }, {});\n};\n\nvar organizeCaptionServices = function organizeCaptionServices(captionServices) {\n  return captionServices.reduce(function (svcObj, svc) {\n    if (!svc) {\n      return svcObj;\n    }\n\n    svc.forEach(function (service) {\n      var channel = service.channel,\n          language = service.language;\n      svcObj[language] = {\n        autoselect: false,\n        default: false,\n        instreamId: channel,\n        language: language\n      };\n\n      if (service.hasOwnProperty('aspectRatio')) {\n        svcObj[language].aspectRatio = service.aspectRatio;\n      }\n\n      if (service.hasOwnProperty('easyReader')) {\n        svcObj[language].easyReader = service.easyReader;\n      }\n\n      if (service.hasOwnProperty('3D')) {\n        svcObj[language]['3D'] = service['3D'];\n      }\n    });\n    return svcObj;\n  }, {});\n};\n\nvar formatVideoPlaylist = function formatVideoPlaylist(_ref3) {\n  var _attributes2;\n\n  var attributes = _ref3.attributes,\n      segments = _ref3.segments,\n      sidx = _ref3.sidx,\n      discontinuityStarts = _ref3.discontinuityStarts;\n  var playlist = {\n    attributes: (_attributes2 = {\n      NAME: attributes.id,\n      AUDIO: 'audio',\n      SUBTITLES: 'subs',\n      RESOLUTION: {\n        width: attributes.width,\n        height: attributes.height\n      },\n      CODECS: attributes.codecs,\n      BANDWIDTH: attributes.bandwidth\n    }, _attributes2['PROGRAM-ID'] = 1, _attributes2),\n    uri: '',\n    endList: attributes.type === 'static',\n    timeline: attributes.periodStart,\n    resolvedUri: '',\n    targetDuration: attributes.duration,\n    discontinuityStarts: discontinuityStarts,\n    timelineStarts: attributes.timelineStarts,\n    segments: segments\n  };\n\n  if (attributes.contentProtection) {\n    playlist.contentProtection = attributes.contentProtection;\n  }\n\n  if (sidx) {\n    playlist.sidx = sidx;\n  }\n\n  return playlist;\n};\n\nvar videoOnly = function videoOnly(_ref4) {\n  var attributes = _ref4.attributes;\n  return attributes.mimeType === 'video/mp4' || attributes.mimeType === 'video/webm' || attributes.contentType === 'video';\n};\n\nvar audioOnly = function audioOnly(_ref5) {\n  var attributes = _ref5.attributes;\n  return attributes.mimeType === 'audio/mp4' || attributes.mimeType === 'audio/webm' || attributes.contentType === 'audio';\n};\n\nvar vttOnly = function vttOnly(_ref6) {\n  var attributes = _ref6.attributes;\n  return attributes.mimeType === 'text/vtt' || attributes.contentType === 'text';\n};\n/**\n * Contains start and timeline properties denoting a timeline start. For DASH, these will\n * be the same number.\n *\n * @typedef {Object} TimelineStart\n * @property {number} start - the start time of the timeline\n * @property {number} timeline - the timeline number\n */\n\n/**\n * Adds appropriate media and discontinuity sequence values to the segments and playlists.\n *\n * Throughout mpd-parser, the `number` attribute is used in relation to `startNumber`, a\n * DASH specific attribute used in constructing segment URI's from templates. However, from\n * an HLS perspective, the `number` attribute on a segment would be its `mediaSequence`\n * value, which should start at the original media sequence value (or 0) and increment by 1\n * for each segment thereafter. Since DASH's `startNumber` values are independent per\n * period, it doesn't make sense to use it for `number`. Instead, assume everything starts\n * from a 0 mediaSequence value and increment from there.\n *\n * Note that VHS currently doesn't use the `number` property, but it can be helpful for\n * debugging and making sense of the manifest.\n *\n * For live playlists, to account for values increasing in manifests when periods are\n * removed on refreshes, merging logic should be used to update the numbers to their\n * appropriate values (to ensure they're sequential and increasing).\n *\n * @param {Object[]} playlists - the playlists to update\n * @param {TimelineStart[]} timelineStarts - the timeline starts for the manifest\n */\n\n\nvar addMediaSequenceValues = function addMediaSequenceValues(playlists, timelineStarts) {\n  // increment all segments sequentially\n  playlists.forEach(function (playlist) {\n    playlist.mediaSequence = 0;\n    playlist.discontinuitySequence = findIndex(timelineStarts, function (_ref7) {\n      var timeline = _ref7.timeline;\n      return timeline === playlist.timeline;\n    });\n\n    if (!playlist.segments) {\n      return;\n    }\n\n    playlist.segments.forEach(function (segment, index) {\n      segment.number = index;\n    });\n  });\n};\n/**\n * Given a media group object, flattens all playlists within the media group into a single\n * array.\n *\n * @param {Object} mediaGroupObject - the media group object\n *\n * @return {Object[]}\n *         The media group playlists\n */\n\n\nvar flattenMediaGroupPlaylists = function flattenMediaGroupPlaylists(mediaGroupObject) {\n  if (!mediaGroupObject) {\n    return [];\n  }\n\n  return Object.keys(mediaGroupObject).reduce(function (acc, label) {\n    var labelContents = mediaGroupObject[label];\n    return acc.concat(labelContents.playlists);\n  }, []);\n};\n\nvar toM3u8 = function toM3u8(_ref8) {\n  var _mediaGroups;\n\n  var dashPlaylists = _ref8.dashPlaylists,\n      locations = _ref8.locations,\n      _ref8$sidxMapping = _ref8.sidxMapping,\n      sidxMapping = _ref8$sidxMapping === void 0 ? {} : _ref8$sidxMapping,\n      previousManifest = _ref8.previousManifest;\n\n  if (!dashPlaylists.length) {\n    return {};\n  } // grab all main manifest attributes\n\n\n  var _dashPlaylists$0$attr = dashPlaylists[0].attributes,\n      duration = _dashPlaylists$0$attr.sourceDuration,\n      type = _dashPlaylists$0$attr.type,\n      suggestedPresentationDelay = _dashPlaylists$0$attr.suggestedPresentationDelay,\n      minimumUpdatePeriod = _dashPlaylists$0$attr.minimumUpdatePeriod;\n  var videoPlaylists = mergeDiscontiguousPlaylists(dashPlaylists.filter(videoOnly)).map(formatVideoPlaylist);\n  var audioPlaylists = mergeDiscontiguousPlaylists(dashPlaylists.filter(audioOnly));\n  var vttPlaylists = mergeDiscontiguousPlaylists(dashPlaylists.filter(vttOnly));\n  var captions = dashPlaylists.map(function (playlist) {\n    return playlist.attributes.captionServices;\n  }).filter(Boolean);\n  var manifest = {\n    allowCache: true,\n    discontinuityStarts: [],\n    segments: [],\n    endList: true,\n    mediaGroups: (_mediaGroups = {\n      AUDIO: {},\n      VIDEO: {}\n    }, _mediaGroups['CLOSED-CAPTIONS'] = {}, _mediaGroups.SUBTITLES = {}, _mediaGroups),\n    uri: '',\n    duration: duration,\n    playlists: addSidxSegmentsToPlaylists(videoPlaylists, sidxMapping)\n  };\n\n  if (minimumUpdatePeriod >= 0) {\n    manifest.minimumUpdatePeriod = minimumUpdatePeriod * 1000;\n  }\n\n  if (locations) {\n    manifest.locations = locations;\n  }\n\n  if (type === 'dynamic') {\n    manifest.suggestedPresentationDelay = suggestedPresentationDelay;\n  }\n\n  var isAudioOnly = manifest.playlists.length === 0;\n  var organizedAudioGroup = audioPlaylists.length ? organizeAudioPlaylists(audioPlaylists, sidxMapping, isAudioOnly) : null;\n  var organizedVttGroup = vttPlaylists.length ? organizeVttPlaylists(vttPlaylists, sidxMapping) : null;\n  var formattedPlaylists = videoPlaylists.concat(flattenMediaGroupPlaylists(organizedAudioGroup), flattenMediaGroupPlaylists(organizedVttGroup));\n  var playlistTimelineStarts = formattedPlaylists.map(function (_ref9) {\n    var timelineStarts = _ref9.timelineStarts;\n    return timelineStarts;\n  });\n  manifest.timelineStarts = getUniqueTimelineStarts(playlistTimelineStarts);\n  addMediaSequenceValues(formattedPlaylists, manifest.timelineStarts);\n\n  if (organizedAudioGroup) {\n    manifest.mediaGroups.AUDIO.audio = organizedAudioGroup;\n  }\n\n  if (organizedVttGroup) {\n    manifest.mediaGroups.SUBTITLES.subs = organizedVttGroup;\n  }\n\n  if (captions.length) {\n    manifest.mediaGroups['CLOSED-CAPTIONS'].cc = organizeCaptionServices(captions);\n  }\n\n  if (previousManifest) {\n    return positionManifestOnTimeline({\n      oldManifest: previousManifest,\n      newManifest: manifest\n    });\n  }\n\n  return manifest;\n};\n/**\n * Calculates the R (repetition) value for a live stream (for the final segment\n * in a manifest where the r value is negative 1)\n *\n * @param {Object} attributes\n *        Object containing all inherited attributes from parent elements with attribute\n *        names as keys\n * @param {number} time\n *        current time (typically the total time up until the final segment)\n * @param {number} duration\n *        duration property for the given <S />\n *\n * @return {number}\n *        R value to reach the end of the given period\n */\n\n\nvar getLiveRValue = function getLiveRValue(attributes, time, duration) {\n  var NOW = attributes.NOW,\n      clientOffset = attributes.clientOffset,\n      availabilityStartTime = attributes.availabilityStartTime,\n      _attributes$timescale = attributes.timescale,\n      timescale = _attributes$timescale === void 0 ? 1 : _attributes$timescale,\n      _attributes$periodSta = attributes.periodStart,\n      periodStart = _attributes$periodSta === void 0 ? 0 : _attributes$periodSta,\n      _attributes$minimumUp = attributes.minimumUpdatePeriod,\n      minimumUpdatePeriod = _attributes$minimumUp === void 0 ? 0 : _attributes$minimumUp;\n  var now = (NOW + clientOffset) / 1000;\n  var periodStartWC = availabilityStartTime + periodStart;\n  var periodEndWC = now + minimumUpdatePeriod;\n  var periodDuration = periodEndWC - periodStartWC;\n  return Math.ceil((periodDuration * timescale - time) / duration);\n};\n/**\n * Uses information provided by SegmentTemplate.SegmentTimeline to determine segment\n * timing and duration\n *\n * @param {Object} attributes\n *        Object containing all inherited attributes from parent elements with attribute\n *        names as keys\n * @param {Object[]} segmentTimeline\n *        List of objects representing the attributes of each S element contained within\n *\n * @return {{number: number, duration: number, time: number, timeline: number}[]}\n *         List of Objects with segment timing and duration info\n */\n\n\nvar parseByTimeline = function parseByTimeline(attributes, segmentTimeline) {\n  var type = attributes.type,\n      _attributes$minimumUp2 = attributes.minimumUpdatePeriod,\n      minimumUpdatePeriod = _attributes$minimumUp2 === void 0 ? 0 : _attributes$minimumUp2,\n      _attributes$media = attributes.media,\n      media = _attributes$media === void 0 ? '' : _attributes$media,\n      sourceDuration = attributes.sourceDuration,\n      _attributes$timescale2 = attributes.timescale,\n      timescale = _attributes$timescale2 === void 0 ? 1 : _attributes$timescale2,\n      _attributes$startNumb = attributes.startNumber,\n      startNumber = _attributes$startNumb === void 0 ? 1 : _attributes$startNumb,\n      timeline = attributes.periodStart;\n  var segments = [];\n  var time = -1;\n\n  for (var sIndex = 0; sIndex < segmentTimeline.length; sIndex++) {\n    var S = segmentTimeline[sIndex];\n    var duration = S.d;\n    var repeat = S.r || 0;\n    var segmentTime = S.t || 0;\n\n    if (time < 0) {\n      // first segment\n      time = segmentTime;\n    }\n\n    if (segmentTime && segmentTime > time) {\n      // discontinuity\n      // TODO: How to handle this type of discontinuity\n      // timeline++ here would treat it like HLS discontuity and content would\n      // get appended without gap\n      // E.G.\n      //  <S t=\"0\" d=\"1\" />\n      //  <S d=\"1\" />\n      //  <S d=\"1\" />\n      //  <S t=\"5\" d=\"1\" />\n      // would have $Time$ values of [0, 1, 2, 5]\n      // should this be appened at time positions [0, 1, 2, 3],(#EXT-X-DISCONTINUITY)\n      // or [0, 1, 2, gap, gap, 5]? (#EXT-X-GAP)\n      // does the value of sourceDuration consider this when calculating arbitrary\n      // negative @r repeat value?\n      // E.G. Same elements as above with this added at the end\n      //  <S d=\"1\" r=\"-1\" />\n      //  with a sourceDuration of 10\n      // Would the 2 gaps be included in the time duration calculations resulting in\n      // 8 segments with $Time$ values of [0, 1, 2, 5, 6, 7, 8, 9] or 10 segments\n      // with $Time$ values of [0, 1, 2, 5, 6, 7, 8, 9, 10, 11] ?\n      time = segmentTime;\n    }\n\n    var count = void 0;\n\n    if (repeat < 0) {\n      var nextS = sIndex + 1;\n\n      if (nextS === segmentTimeline.length) {\n        // last segment\n        if (type === 'dynamic' && minimumUpdatePeriod > 0 && media.indexOf('$Number$') > 0) {\n          count = getLiveRValue(attributes, time, duration);\n        } else {\n          // TODO: This may be incorrect depending on conclusion of TODO above\n          count = (sourceDuration * timescale - time) / duration;\n        }\n      } else {\n        count = (segmentTimeline[nextS].t - time) / duration;\n      }\n    } else {\n      count = repeat + 1;\n    }\n\n    var end = startNumber + segments.length + count;\n    var number = startNumber + segments.length;\n\n    while (number < end) {\n      segments.push({\n        number: number,\n        duration: duration / timescale,\n        time: time,\n        timeline: timeline\n      });\n      time += duration;\n      number++;\n    }\n  }\n\n  return segments;\n};\n\nvar identifierPattern = /\\$([A-z]*)(?:(%0)([0-9]+)d)?\\$/g;\n/**\n * Replaces template identifiers with corresponding values. To be used as the callback\n * for String.prototype.replace\n *\n * @name replaceCallback\n * @function\n * @param {string} match\n *        Entire match of identifier\n * @param {string} identifier\n *        Name of matched identifier\n * @param {string} format\n *        Format tag string. Its presence indicates that padding is expected\n * @param {string} width\n *        Desired length of the replaced value. Values less than this width shall be left\n *        zero padded\n * @return {string}\n *         Replacement for the matched identifier\n */\n\n/**\n * Returns a function to be used as a callback for String.prototype.replace to replace\n * template identifiers\n *\n * @param {Obect} values\n *        Object containing values that shall be used to replace known identifiers\n * @param {number} values.RepresentationID\n *        Value of the Representation@id attribute\n * @param {number} values.Number\n *        Number of the corresponding segment\n * @param {number} values.Bandwidth\n *        Value of the Representation@bandwidth attribute.\n * @param {number} values.Time\n *        Timestamp value of the corresponding segment\n * @return {replaceCallback}\n *         Callback to be used with String.prototype.replace to replace identifiers\n */\n\nvar identifierReplacement = function identifierReplacement(values) {\n  return function (match, identifier, format, width) {\n    if (match === '$$') {\n      // escape sequence\n      return '$';\n    }\n\n    if (typeof values[identifier] === 'undefined') {\n      return match;\n    }\n\n    var value = '' + values[identifier];\n\n    if (identifier === 'RepresentationID') {\n      // Format tag shall not be present with RepresentationID\n      return value;\n    }\n\n    if (!format) {\n      width = 1;\n    } else {\n      width = parseInt(width, 10);\n    }\n\n    if (value.length >= width) {\n      return value;\n    }\n\n    return \"\" + new Array(width - value.length + 1).join('0') + value;\n  };\n};\n/**\n * Constructs a segment url from a template string\n *\n * @param {string} url\n *        Template string to construct url from\n * @param {Obect} values\n *        Object containing values that shall be used to replace known identifiers\n * @param {number} values.RepresentationID\n *        Value of the Representation@id attribute\n * @param {number} values.Number\n *        Number of the corresponding segment\n * @param {number} values.Bandwidth\n *        Value of the Representation@bandwidth attribute.\n * @param {number} values.Time\n *        Timestamp value of the corresponding segment\n * @return {string}\n *         Segment url with identifiers replaced\n */\n\n\nvar constructTemplateUrl = function constructTemplateUrl(url, values) {\n  return url.replace(identifierPattern, identifierReplacement(values));\n};\n/**\n * Generates a list of objects containing timing and duration information about each\n * segment needed to generate segment uris and the complete segment object\n *\n * @param {Object} attributes\n *        Object containing all inherited attributes from parent elements with attribute\n *        names as keys\n * @param {Object[]|undefined} segmentTimeline\n *        List of objects representing the attributes of each S element contained within\n *        the SegmentTimeline element\n * @return {{number: number, duration: number, time: number, timeline: number}[]}\n *         List of Objects with segment timing and duration info\n */\n\n\nvar parseTemplateInfo = function parseTemplateInfo(attributes, segmentTimeline) {\n  if (!attributes.duration && !segmentTimeline) {\n    // if neither @duration or SegmentTimeline are present, then there shall be exactly\n    // one media segment\n    return [{\n      number: attributes.startNumber || 1,\n      duration: attributes.sourceDuration,\n      time: 0,\n      timeline: attributes.periodStart\n    }];\n  }\n\n  if (attributes.duration) {\n    return parseByDuration(attributes);\n  }\n\n  return parseByTimeline(attributes, segmentTimeline);\n};\n/**\n * Generates a list of segments using information provided by the SegmentTemplate element\n *\n * @param {Object} attributes\n *        Object containing all inherited attributes from parent elements with attribute\n *        names as keys\n * @param {Object[]|undefined} segmentTimeline\n *        List of objects representing the attributes of each S element contained within\n *        the SegmentTimeline element\n * @return {Object[]}\n *         List of segment objects\n */\n\n\nvar segmentsFromTemplate = function segmentsFromTemplate(attributes, segmentTimeline) {\n  var templateValues = {\n    RepresentationID: attributes.id,\n    Bandwidth: attributes.bandwidth || 0\n  };\n  var _attributes$initializ = attributes.initialization,\n      initialization = _attributes$initializ === void 0 ? {\n    sourceURL: '',\n    range: ''\n  } : _attributes$initializ;\n  var mapSegment = urlTypeToSegment({\n    baseUrl: attributes.baseUrl,\n    source: constructTemplateUrl(initialization.sourceURL, templateValues),\n    range: initialization.range\n  });\n  var segments = parseTemplateInfo(attributes, segmentTimeline);\n  return segments.map(function (segment) {\n    templateValues.Number = segment.number;\n    templateValues.Time = segment.time;\n    var uri = constructTemplateUrl(attributes.media || '', templateValues); // See DASH spec section 5.3.9.2.2\n    // - if timescale isn't present on any level, default to 1.\n\n    var timescale = attributes.timescale || 1; // - if presentationTimeOffset isn't present on any level, default to 0\n\n    var presentationTimeOffset = attributes.presentationTimeOffset || 0;\n    var presentationTime = // Even if the @t attribute is not specified for the segment, segment.time is\n    // calculated in mpd-parser prior to this, so it's assumed to be available.\n    attributes.periodStart + (segment.time - presentationTimeOffset) / timescale;\n    var map = {\n      uri: uri,\n      timeline: segment.timeline,\n      duration: segment.duration,\n      resolvedUri: resolveUrl(attributes.baseUrl || '', uri),\n      map: mapSegment,\n      number: segment.number,\n      presentationTime: presentationTime\n    };\n    return map;\n  });\n};\n/**\n * Converts a <SegmentUrl> (of type URLType from the DASH spec 5.3.9.2 Table 14)\n * to an object that matches the output of a segment in videojs/mpd-parser\n *\n * @param {Object} attributes\n *   Object containing all inherited attributes from parent elements with attribute\n *   names as keys\n * @param {Object} segmentUrl\n *   <SegmentURL> node to translate into a segment object\n * @return {Object} translated segment object\n */\n\n\nvar SegmentURLToSegmentObject = function SegmentURLToSegmentObject(attributes, segmentUrl) {\n  var baseUrl = attributes.baseUrl,\n      _attributes$initializ = attributes.initialization,\n      initialization = _attributes$initializ === void 0 ? {} : _attributes$initializ;\n  var initSegment = urlTypeToSegment({\n    baseUrl: baseUrl,\n    source: initialization.sourceURL,\n    range: initialization.range\n  });\n  var segment = urlTypeToSegment({\n    baseUrl: baseUrl,\n    source: segmentUrl.media,\n    range: segmentUrl.mediaRange\n  });\n  segment.map = initSegment;\n  return segment;\n};\n/**\n * Generates a list of segments using information provided by the SegmentList element\n * SegmentList (DASH SPEC Section 5.3.9.3.2) contains a set of <SegmentURL> nodes.  Each\n * node should be translated into segment.\n *\n * @param {Object} attributes\n *   Object containing all inherited attributes from parent elements with attribute\n *   names as keys\n * @param {Object[]|undefined} segmentTimeline\n *        List of objects representing the attributes of each S element contained within\n *        the SegmentTimeline element\n * @return {Object.<Array>} list of segments\n */\n\n\nvar segmentsFromList = function segmentsFromList(attributes, segmentTimeline) {\n  var duration = attributes.duration,\n      _attributes$segmentUr = attributes.segmentUrls,\n      segmentUrls = _attributes$segmentUr === void 0 ? [] : _attributes$segmentUr,\n      periodStart = attributes.periodStart; // Per spec (5.3.9.2.1) no way to determine segment duration OR\n  // if both SegmentTimeline and @duration are defined, it is outside of spec.\n\n  if (!duration && !segmentTimeline || duration && segmentTimeline) {\n    throw new Error(errors.SEGMENT_TIME_UNSPECIFIED);\n  }\n\n  var segmentUrlMap = segmentUrls.map(function (segmentUrlObject) {\n    return SegmentURLToSegmentObject(attributes, segmentUrlObject);\n  });\n  var segmentTimeInfo;\n\n  if (duration) {\n    segmentTimeInfo = parseByDuration(attributes);\n  }\n\n  if (segmentTimeline) {\n    segmentTimeInfo = parseByTimeline(attributes, segmentTimeline);\n  }\n\n  var segments = segmentTimeInfo.map(function (segmentTime, index) {\n    if (segmentUrlMap[index]) {\n      var segment = segmentUrlMap[index]; // See DASH spec section 5.3.9.2.2\n      // - if timescale isn't present on any level, default to 1.\n\n      var timescale = attributes.timescale || 1; // - if presentationTimeOffset isn't present on any level, default to 0\n\n      var presentationTimeOffset = attributes.presentationTimeOffset || 0;\n      segment.timeline = segmentTime.timeline;\n      segment.duration = segmentTime.duration;\n      segment.number = segmentTime.number;\n      segment.presentationTime = periodStart + (segmentTime.time - presentationTimeOffset) / timescale;\n      return segment;\n    } // Since we're mapping we should get rid of any blank segments (in case\n    // the given SegmentTimeline is handling for more elements than we have\n    // SegmentURLs for).\n\n  }).filter(function (segment) {\n    return segment;\n  });\n  return segments;\n};\n\nvar generateSegments = function generateSegments(_ref) {\n  var attributes = _ref.attributes,\n      segmentInfo = _ref.segmentInfo;\n  var segmentAttributes;\n  var segmentsFn;\n\n  if (segmentInfo.template) {\n    segmentsFn = segmentsFromTemplate;\n    segmentAttributes = merge(attributes, segmentInfo.template);\n  } else if (segmentInfo.base) {\n    segmentsFn = segmentsFromBase;\n    segmentAttributes = merge(attributes, segmentInfo.base);\n  } else if (segmentInfo.list) {\n    segmentsFn = segmentsFromList;\n    segmentAttributes = merge(attributes, segmentInfo.list);\n  }\n\n  var segmentsInfo = {\n    attributes: attributes\n  };\n\n  if (!segmentsFn) {\n    return segmentsInfo;\n  }\n\n  var segments = segmentsFn(segmentAttributes, segmentInfo.segmentTimeline); // The @duration attribute will be used to determin the playlist's targetDuration which\n  // must be in seconds. Since we've generated the segment list, we no longer need\n  // @duration to be in @timescale units, so we can convert it here.\n\n  if (segmentAttributes.duration) {\n    var _segmentAttributes = segmentAttributes,\n        duration = _segmentAttributes.duration,\n        _segmentAttributes$ti = _segmentAttributes.timescale,\n        timescale = _segmentAttributes$ti === void 0 ? 1 : _segmentAttributes$ti;\n    segmentAttributes.duration = duration / timescale;\n  } else if (segments.length) {\n    // if there is no @duration attribute, use the largest segment duration as\n    // as target duration\n    segmentAttributes.duration = segments.reduce(function (max, segment) {\n      return Math.max(max, Math.ceil(segment.duration));\n    }, 0);\n  } else {\n    segmentAttributes.duration = 0;\n  }\n\n  segmentsInfo.attributes = segmentAttributes;\n  segmentsInfo.segments = segments; // This is a sidx box without actual segment information\n\n  if (segmentInfo.base && segmentAttributes.indexRange) {\n    segmentsInfo.sidx = segments[0];\n    segmentsInfo.segments = [];\n  }\n\n  return segmentsInfo;\n};\n\nvar toPlaylists = function toPlaylists(representations) {\n  return representations.map(generateSegments);\n};\n\nvar findChildren = function findChildren(element, name) {\n  return from(element.childNodes).filter(function (_ref) {\n    var tagName = _ref.tagName;\n    return tagName === name;\n  });\n};\n\nvar getContent = function getContent(element) {\n  return element.textContent.trim();\n};\n\nvar parseDuration = function parseDuration(str) {\n  var SECONDS_IN_YEAR = 365 * 24 * 60 * 60;\n  var SECONDS_IN_MONTH = 30 * 24 * 60 * 60;\n  var SECONDS_IN_DAY = 24 * 60 * 60;\n  var SECONDS_IN_HOUR = 60 * 60;\n  var SECONDS_IN_MIN = 60; // P10Y10M10DT10H10M10.1S\n\n  var durationRegex = /P(?:(\\d*)Y)?(?:(\\d*)M)?(?:(\\d*)D)?(?:T(?:(\\d*)H)?(?:(\\d*)M)?(?:([\\d.]*)S)?)?/;\n  var match = durationRegex.exec(str);\n\n  if (!match) {\n    return 0;\n  }\n\n  var _match$slice = match.slice(1),\n      year = _match$slice[0],\n      month = _match$slice[1],\n      day = _match$slice[2],\n      hour = _match$slice[3],\n      minute = _match$slice[4],\n      second = _match$slice[5];\n\n  return parseFloat(year || 0) * SECONDS_IN_YEAR + parseFloat(month || 0) * SECONDS_IN_MONTH + parseFloat(day || 0) * SECONDS_IN_DAY + parseFloat(hour || 0) * SECONDS_IN_HOUR + parseFloat(minute || 0) * SECONDS_IN_MIN + parseFloat(second || 0);\n};\n\nvar parseDate = function parseDate(str) {\n  // Date format without timezone according to ISO 8601\n  // YYY-MM-DDThh:mm:ss.ssssss\n  var dateRegex = /^\\d+-\\d+-\\d+T\\d+:\\d+:\\d+(\\.\\d+)?$/; // If the date string does not specifiy a timezone, we must specifiy UTC. This is\n  // expressed by ending with 'Z'\n\n  if (dateRegex.test(str)) {\n    str += 'Z';\n  }\n\n  return Date.parse(str);\n};\n\nvar parsers = {\n  /**\n   * Specifies the duration of the entire Media Presentation. Format is a duration string\n   * as specified in ISO 8601\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The duration in seconds\n   */\n  mediaPresentationDuration: function mediaPresentationDuration(value) {\n    return parseDuration(value);\n  },\n\n  /**\n   * Specifies the Segment availability start time for all Segments referred to in this\n   * MPD. For a dynamic manifest, it specifies the anchor for the earliest availability\n   * time. Format is a date string as specified in ISO 8601\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The date as seconds from unix epoch\n   */\n  availabilityStartTime: function availabilityStartTime(value) {\n    return parseDate(value) / 1000;\n  },\n\n  /**\n   * Specifies the smallest period between potential changes to the MPD. Format is a\n   * duration string as specified in ISO 8601\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The duration in seconds\n   */\n  minimumUpdatePeriod: function minimumUpdatePeriod(value) {\n    return parseDuration(value);\n  },\n\n  /**\n   * Specifies the suggested presentation delay. Format is a\n   * duration string as specified in ISO 8601\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The duration in seconds\n   */\n  suggestedPresentationDelay: function suggestedPresentationDelay(value) {\n    return parseDuration(value);\n  },\n\n  /**\n   * specifices the type of mpd. Can be either \"static\" or \"dynamic\"\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   *\n   * @return {string}\n   *         The type as a string\n   */\n  type: function type(value) {\n    return value;\n  },\n\n  /**\n   * Specifies the duration of the smallest time shifting buffer for any Representation\n   * in the MPD. Format is a duration string as specified in ISO 8601\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The duration in seconds\n   */\n  timeShiftBufferDepth: function timeShiftBufferDepth(value) {\n    return parseDuration(value);\n  },\n\n  /**\n   * Specifies the PeriodStart time of the Period relative to the availabilityStarttime.\n   * Format is a duration string as specified in ISO 8601\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The duration in seconds\n   */\n  start: function start(value) {\n    return parseDuration(value);\n  },\n\n  /**\n   * Specifies the width of the visual presentation\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The parsed width\n   */\n  width: function width(value) {\n    return parseInt(value, 10);\n  },\n\n  /**\n   * Specifies the height of the visual presentation\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The parsed height\n   */\n  height: function height(value) {\n    return parseInt(value, 10);\n  },\n\n  /**\n   * Specifies the bitrate of the representation\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The parsed bandwidth\n   */\n  bandwidth: function bandwidth(value) {\n    return parseInt(value, 10);\n  },\n\n  /**\n   * Specifies the number of the first Media Segment in this Representation in the Period\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The parsed number\n   */\n  startNumber: function startNumber(value) {\n    return parseInt(value, 10);\n  },\n\n  /**\n   * Specifies the timescale in units per seconds\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The parsed timescale\n   */\n  timescale: function timescale(value) {\n    return parseInt(value, 10);\n  },\n\n  /**\n   * Specifies the presentationTimeOffset.\n   *\n   * @param {string} value\n   *        value of the attribute as a string\n   *\n   * @return {number}\n   *         The parsed presentationTimeOffset\n   */\n  presentationTimeOffset: function presentationTimeOffset(value) {\n    return parseInt(value, 10);\n  },\n\n  /**\n   * Specifies the constant approximate Segment duration\n   * NOTE: The <Period> element also contains an @duration attribute. This duration\n   *       specifies the duration of the Period. This attribute is currently not\n   *       supported by the rest of the parser, however we still check for it to prevent\n   *       errors.\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The parsed duration\n   */\n  duration: function duration(value) {\n    var parsedValue = parseInt(value, 10);\n\n    if (isNaN(parsedValue)) {\n      return parseDuration(value);\n    }\n\n    return parsedValue;\n  },\n\n  /**\n   * Specifies the Segment duration, in units of the value of the @timescale.\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The parsed duration\n   */\n  d: function d(value) {\n    return parseInt(value, 10);\n  },\n\n  /**\n   * Specifies the MPD start time, in @timescale units, the first Segment in the series\n   * starts relative to the beginning of the Period\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The parsed time\n   */\n  t: function t(value) {\n    return parseInt(value, 10);\n  },\n\n  /**\n   * Specifies the repeat count of the number of following contiguous Segments with the\n   * same duration expressed by the value of @d\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The parsed number\n   */\n  r: function r(value) {\n    return parseInt(value, 10);\n  },\n\n  /**\n   * Default parser for all other attributes. Acts as a no-op and just returns the value\n   * as a string\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {string}\n   *         Unparsed value\n   */\n  DEFAULT: function DEFAULT(value) {\n    return value;\n  }\n};\n/**\n * Gets all the attributes and values of the provided node, parses attributes with known\n * types, and returns an object with attribute names mapped to values.\n *\n * @param {Node} el\n *        The node to parse attributes from\n * @return {Object}\n *         Object with all attributes of el parsed\n */\n\nvar parseAttributes = function parseAttributes(el) {\n  if (!(el && el.attributes)) {\n    return {};\n  }\n\n  return from(el.attributes).reduce(function (a, e) {\n    var parseFn = parsers[e.name] || parsers.DEFAULT;\n    a[e.name] = parseFn(e.value);\n    return a;\n  }, {});\n};\n\nvar keySystemsMap = {\n  'urn:uuid:1077efec-c0b2-4d02-ace3-3c1e52e2fb4b': 'org.w3.clearkey',\n  'urn:uuid:edef8ba9-79d6-4ace-a3c8-27dcd51d21ed': 'com.widevine.alpha',\n  'urn:uuid:9a04f079-9840-4286-ab92-e65be0885f95': 'com.microsoft.playready',\n  'urn:uuid:f239e769-efa3-4850-9c16-a903c6932efb': 'com.adobe.primetime'\n};\n/**\n * Builds a list of urls that is the product of the reference urls and BaseURL values\n *\n * @param {string[]} referenceUrls\n *        List of reference urls to resolve to\n * @param {Node[]} baseUrlElements\n *        List of BaseURL nodes from the mpd\n * @return {string[]}\n *         List of resolved urls\n */\n\nvar buildBaseUrls = function buildBaseUrls(referenceUrls, baseUrlElements) {\n  if (!baseUrlElements.length) {\n    return referenceUrls;\n  }\n\n  return flatten(referenceUrls.map(function (reference) {\n    return baseUrlElements.map(function (baseUrlElement) {\n      return resolveUrl(reference, getContent(baseUrlElement));\n    });\n  }));\n};\n/**\n * Contains all Segment information for its containing AdaptationSet\n *\n * @typedef {Object} SegmentInformation\n * @property {Object|undefined} template\n *           Contains the attributes for the SegmentTemplate node\n * @property {Object[]|undefined} segmentTimeline\n *           Contains a list of atrributes for each S node within the SegmentTimeline node\n * @property {Object|undefined} list\n *           Contains the attributes for the SegmentList node\n * @property {Object|undefined} base\n *           Contains the attributes for the SegmentBase node\n */\n\n/**\n * Returns all available Segment information contained within the AdaptationSet node\n *\n * @param {Node} adaptationSet\n *        The AdaptationSet node to get Segment information from\n * @return {SegmentInformation}\n *         The Segment information contained within the provided AdaptationSet\n */\n\n\nvar getSegmentInformation = function getSegmentInformation(adaptationSet) {\n  var segmentTemplate = findChildren(adaptationSet, 'SegmentTemplate')[0];\n  var segmentList = findChildren(adaptationSet, 'SegmentList')[0];\n  var segmentUrls = segmentList && findChildren(segmentList, 'SegmentURL').map(function (s) {\n    return merge({\n      tag: 'SegmentURL'\n    }, parseAttributes(s));\n  });\n  var segmentBase = findChildren(adaptationSet, 'SegmentBase')[0];\n  var segmentTimelineParentNode = segmentList || segmentTemplate;\n  var segmentTimeline = segmentTimelineParentNode && findChildren(segmentTimelineParentNode, 'SegmentTimeline')[0];\n  var segmentInitializationParentNode = segmentList || segmentBase || segmentTemplate;\n  var segmentInitialization = segmentInitializationParentNode && findChildren(segmentInitializationParentNode, 'Initialization')[0]; // SegmentTemplate is handled slightly differently, since it can have both\n  // @initialization and an <Initialization> node.  @initialization can be templated,\n  // while the node can have a url and range specified.  If the <SegmentTemplate> has\n  // both @initialization and an <Initialization> subelement we opt to override with\n  // the node, as this interaction is not defined in the spec.\n\n  var template = segmentTemplate && parseAttributes(segmentTemplate);\n\n  if (template && segmentInitialization) {\n    template.initialization = segmentInitialization && parseAttributes(segmentInitialization);\n  } else if (template && template.initialization) {\n    // If it is @initialization we convert it to an object since this is the format that\n    // later functions will rely on for the initialization segment.  This is only valid\n    // for <SegmentTemplate>\n    template.initialization = {\n      sourceURL: template.initialization\n    };\n  }\n\n  var segmentInfo = {\n    template: template,\n    segmentTimeline: segmentTimeline && findChildren(segmentTimeline, 'S').map(function (s) {\n      return parseAttributes(s);\n    }),\n    list: segmentList && merge(parseAttributes(segmentList), {\n      segmentUrls: segmentUrls,\n      initialization: parseAttributes(segmentInitialization)\n    }),\n    base: segmentBase && merge(parseAttributes(segmentBase), {\n      initialization: parseAttributes(segmentInitialization)\n    })\n  };\n  Object.keys(segmentInfo).forEach(function (key) {\n    if (!segmentInfo[key]) {\n      delete segmentInfo[key];\n    }\n  });\n  return segmentInfo;\n};\n/**\n * Contains Segment information and attributes needed to construct a Playlist object\n * from a Representation\n *\n * @typedef {Object} RepresentationInformation\n * @property {SegmentInformation} segmentInfo\n *           Segment information for this Representation\n * @property {Object} attributes\n *           Inherited attributes for this Representation\n */\n\n/**\n * Maps a Representation node to an object containing Segment information and attributes\n *\n * @name inheritBaseUrlsCallback\n * @function\n * @param {Node} representation\n *        Representation node from the mpd\n * @return {RepresentationInformation}\n *         Representation information needed to construct a Playlist object\n */\n\n/**\n * Returns a callback for Array.prototype.map for mapping Representation nodes to\n * Segment information and attributes using inherited BaseURL nodes.\n *\n * @param {Object} adaptationSetAttributes\n *        Contains attributes inherited by the AdaptationSet\n * @param {string[]} adaptationSetBaseUrls\n *        Contains list of resolved base urls inherited by the AdaptationSet\n * @param {SegmentInformation} adaptationSetSegmentInfo\n *        Contains Segment information for the AdaptationSet\n * @return {inheritBaseUrlsCallback}\n *         Callback map function\n */\n\n\nvar inheritBaseUrls = function inheritBaseUrls(adaptationSetAttributes, adaptationSetBaseUrls, adaptationSetSegmentInfo) {\n  return function (representation) {\n    var repBaseUrlElements = findChildren(representation, 'BaseURL');\n    var repBaseUrls = buildBaseUrls(adaptationSetBaseUrls, repBaseUrlElements);\n    var attributes = merge(adaptationSetAttributes, parseAttributes(representation));\n    var representationSegmentInfo = getSegmentInformation(representation);\n    return repBaseUrls.map(function (baseUrl) {\n      return {\n        segmentInfo: merge(adaptationSetSegmentInfo, representationSegmentInfo),\n        attributes: merge(attributes, {\n          baseUrl: baseUrl\n        })\n      };\n    });\n  };\n};\n/**\n * Tranforms a series of content protection nodes to\n * an object containing pssh data by key system\n *\n * @param {Node[]} contentProtectionNodes\n *        Content protection nodes\n * @return {Object}\n *        Object containing pssh data by key system\n */\n\n\nvar generateKeySystemInformation = function generateKeySystemInformation(contentProtectionNodes) {\n  return contentProtectionNodes.reduce(function (acc, node) {\n    var attributes = parseAttributes(node); // Although it could be argued that according to the UUID RFC spec the UUID string (a-f chars) should be generated\n    // as a lowercase string it also mentions it should be treated as case-insensitive on input. Since the key system\n    // UUIDs in the keySystemsMap are hardcoded as lowercase in the codebase there isn't any reason not to do\n    // .toLowerCase() on the input UUID string from the manifest (at least I could not think of one).\n\n    if (attributes.schemeIdUri) {\n      attributes.schemeIdUri = attributes.schemeIdUri.toLowerCase();\n    }\n\n    var keySystem = keySystemsMap[attributes.schemeIdUri];\n\n    if (keySystem) {\n      acc[keySystem] = {\n        attributes: attributes\n      };\n      var psshNode = findChildren(node, 'cenc:pssh')[0];\n\n      if (psshNode) {\n        var pssh = getContent(psshNode);\n        acc[keySystem].pssh = pssh && decodeB64ToUint8Array(pssh);\n      }\n    }\n\n    return acc;\n  }, {});\n}; // defined in ANSI_SCTE 214-1 2016\n\n\nvar parseCaptionServiceMetadata = function parseCaptionServiceMetadata(service) {\n  // 608 captions\n  if (service.schemeIdUri === 'urn:scte:dash:cc:cea-608:2015') {\n    var values = typeof service.value !== 'string' ? [] : service.value.split(';');\n    return values.map(function (value) {\n      var channel;\n      var language; // default language to value\n\n      language = value;\n\n      if (/^CC\\d=/.test(value)) {\n        var _value$split = value.split('=');\n\n        channel = _value$split[0];\n        language = _value$split[1];\n      } else if (/^CC\\d$/.test(value)) {\n        channel = value;\n      }\n\n      return {\n        channel: channel,\n        language: language\n      };\n    });\n  } else if (service.schemeIdUri === 'urn:scte:dash:cc:cea-708:2015') {\n    var _values = typeof service.value !== 'string' ? [] : service.value.split(';');\n\n    return _values.map(function (value) {\n      var flags = {\n        // service or channel number 1-63\n        'channel': undefined,\n        // language is a 3ALPHA per ISO 639.2/B\n        // field is required\n        'language': undefined,\n        // BIT 1/0 or ?\n        // default value is 1, meaning 16:9 aspect ratio, 0 is 4:3, ? is unknown\n        'aspectRatio': 1,\n        // BIT 1/0\n        // easy reader flag indicated the text is tailed to the needs of beginning readers\n        // default 0, or off\n        'easyReader': 0,\n        // BIT 1/0\n        // If 3d metadata is present (CEA-708.1) then 1\n        // default 0\n        '3D': 0\n      };\n\n      if (/=/.test(value)) {\n        var _value$split2 = value.split('='),\n            channel = _value$split2[0],\n            _value$split2$ = _value$split2[1],\n            opts = _value$split2$ === void 0 ? '' : _value$split2$;\n\n        flags.channel = channel;\n        flags.language = value;\n        opts.split(',').forEach(function (opt) {\n          var _opt$split = opt.split(':'),\n              name = _opt$split[0],\n              val = _opt$split[1];\n\n          if (name === 'lang') {\n            flags.language = val; // er for easyReadery\n          } else if (name === 'er') {\n            flags.easyReader = Number(val); // war for wide aspect ratio\n          } else if (name === 'war') {\n            flags.aspectRatio = Number(val);\n          } else if (name === '3D') {\n            flags['3D'] = Number(val);\n          }\n        });\n      } else {\n        flags.language = value;\n      }\n\n      if (flags.channel) {\n        flags.channel = 'SERVICE' + flags.channel;\n      }\n\n      return flags;\n    });\n  }\n};\n/**\n * Maps an AdaptationSet node to a list of Representation information objects\n *\n * @name toRepresentationsCallback\n * @function\n * @param {Node} adaptationSet\n *        AdaptationSet node from the mpd\n * @return {RepresentationInformation[]}\n *         List of objects containing Representaion information\n */\n\n/**\n * Returns a callback for Array.prototype.map for mapping AdaptationSet nodes to a list of\n * Representation information objects\n *\n * @param {Object} periodAttributes\n *        Contains attributes inherited by the Period\n * @param {string[]} periodBaseUrls\n *        Contains list of resolved base urls inherited by the Period\n * @param {string[]} periodSegmentInfo\n *        Contains Segment Information at the period level\n * @return {toRepresentationsCallback}\n *         Callback map function\n */\n\n\nvar toRepresentations = function toRepresentations(periodAttributes, periodBaseUrls, periodSegmentInfo) {\n  return function (adaptationSet) {\n    var adaptationSetAttributes = parseAttributes(adaptationSet);\n    var adaptationSetBaseUrls = buildBaseUrls(periodBaseUrls, findChildren(adaptationSet, 'BaseURL'));\n    var role = findChildren(adaptationSet, 'Role')[0];\n    var roleAttributes = {\n      role: parseAttributes(role)\n    };\n    var attrs = merge(periodAttributes, adaptationSetAttributes, roleAttributes);\n    var accessibility = findChildren(adaptationSet, 'Accessibility')[0];\n    var captionServices = parseCaptionServiceMetadata(parseAttributes(accessibility));\n\n    if (captionServices) {\n      attrs = merge(attrs, {\n        captionServices: captionServices\n      });\n    }\n\n    var label = findChildren(adaptationSet, 'Label')[0];\n\n    if (label && label.childNodes.length) {\n      var labelVal = label.childNodes[0].nodeValue.trim();\n      attrs = merge(attrs, {\n        label: labelVal\n      });\n    }\n\n    var contentProtection = generateKeySystemInformation(findChildren(adaptationSet, 'ContentProtection'));\n\n    if (Object.keys(contentProtection).length) {\n      attrs = merge(attrs, {\n        contentProtection: contentProtection\n      });\n    }\n\n    var segmentInfo = getSegmentInformation(adaptationSet);\n    var representations = findChildren(adaptationSet, 'Representation');\n    var adaptationSetSegmentInfo = merge(periodSegmentInfo, segmentInfo);\n    return flatten(representations.map(inheritBaseUrls(attrs, adaptationSetBaseUrls, adaptationSetSegmentInfo)));\n  };\n};\n/**\n * Contains all period information for mapping nodes onto adaptation sets.\n *\n * @typedef {Object} PeriodInformation\n * @property {Node} period.node\n *           Period node from the mpd\n * @property {Object} period.attributes\n *           Parsed period attributes from node plus any added\n */\n\n/**\n * Maps a PeriodInformation object to a list of Representation information objects for all\n * AdaptationSet nodes contained within the Period.\n *\n * @name toAdaptationSetsCallback\n * @function\n * @param {PeriodInformation} period\n *        Period object containing necessary period information\n * @param {number} periodStart\n *        Start time of the Period within the mpd\n * @return {RepresentationInformation[]}\n *         List of objects containing Representaion information\n */\n\n/**\n * Returns a callback for Array.prototype.map for mapping Period nodes to a list of\n * Representation information objects\n *\n * @param {Object} mpdAttributes\n *        Contains attributes inherited by the mpd\n * @param {string[]} mpdBaseUrls\n *        Contains list of resolved base urls inherited by the mpd\n * @return {toAdaptationSetsCallback}\n *         Callback map function\n */\n\n\nvar toAdaptationSets = function toAdaptationSets(mpdAttributes, mpdBaseUrls) {\n  return function (period, index) {\n    var periodBaseUrls = buildBaseUrls(mpdBaseUrls, findChildren(period.node, 'BaseURL'));\n    var periodAttributes = merge(mpdAttributes, {\n      periodStart: period.attributes.start\n    });\n\n    if (typeof period.attributes.duration === 'number') {\n      periodAttributes.periodDuration = period.attributes.duration;\n    }\n\n    var adaptationSets = findChildren(period.node, 'AdaptationSet');\n    var periodSegmentInfo = getSegmentInformation(period.node);\n    return flatten(adaptationSets.map(toRepresentations(periodAttributes, periodBaseUrls, periodSegmentInfo)));\n  };\n};\n/**\n * Gets Period@start property for a given period.\n *\n * @param {Object} options\n *        Options object\n * @param {Object} options.attributes\n *        Period attributes\n * @param {Object} [options.priorPeriodAttributes]\n *        Prior period attributes (if prior period is available)\n * @param {string} options.mpdType\n *        The MPD@type these periods came from\n * @return {number|null}\n *         The period start, or null if it's an early available period or error\n */\n\n\nvar getPeriodStart = function getPeriodStart(_ref) {\n  var attributes = _ref.attributes,\n      priorPeriodAttributes = _ref.priorPeriodAttributes,\n      mpdType = _ref.mpdType; // Summary of period start time calculation from DASH spec section 5.3.2.1\n  //\n  // A period's start is the first period's start + time elapsed after playing all\n  // prior periods to this one. Periods continue one after the other in time (without\n  // gaps) until the end of the presentation.\n  //\n  // The value of Period@start should be:\n  // 1. if Period@start is present: value of Period@start\n  // 2. if previous period exists and it has @duration: previous Period@start +\n  //    previous Period@duration\n  // 3. if this is first period and MPD@type is 'static': 0\n  // 4. in all other cases, consider the period an \"early available period\" (note: not\n  //    currently supported)\n  // (1)\n\n  if (typeof attributes.start === 'number') {\n    return attributes.start;\n  } // (2)\n\n\n  if (priorPeriodAttributes && typeof priorPeriodAttributes.start === 'number' && typeof priorPeriodAttributes.duration === 'number') {\n    return priorPeriodAttributes.start + priorPeriodAttributes.duration;\n  } // (3)\n\n\n  if (!priorPeriodAttributes && mpdType === 'static') {\n    return 0;\n  } // (4)\n  // There is currently no logic for calculating the Period@start value if there is\n  // no Period@start or prior Period@start and Period@duration available. This is not made\n  // explicit by the DASH interop guidelines or the DASH spec, however, since there's\n  // nothing about any other resolution strategies, it's implied. Thus, this case should\n  // be considered an early available period, or error, and null should suffice for both\n  // of those cases.\n\n\n  return null;\n};\n/**\n * Traverses the mpd xml tree to generate a list of Representation information objects\n * that have inherited attributes from parent nodes\n *\n * @param {Node} mpd\n *        The root node of the mpd\n * @param {Object} options\n *        Available options for inheritAttributes\n * @param {string} options.manifestUri\n *        The uri source of the mpd\n * @param {number} options.NOW\n *        Current time per DASH IOP.  Default is current time in ms since epoch\n * @param {number} options.clientOffset\n *        Client time difference from NOW (in milliseconds)\n * @return {RepresentationInformation[]}\n *         List of objects containing Representation information\n */\n\n\nvar inheritAttributes = function inheritAttributes(mpd, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var _options = options,\n      _options$manifestUri = _options.manifestUri,\n      manifestUri = _options$manifestUri === void 0 ? '' : _options$manifestUri,\n      _options$NOW = _options.NOW,\n      NOW = _options$NOW === void 0 ? Date.now() : _options$NOW,\n      _options$clientOffset = _options.clientOffset,\n      clientOffset = _options$clientOffset === void 0 ? 0 : _options$clientOffset;\n  var periodNodes = findChildren(mpd, 'Period');\n\n  if (!periodNodes.length) {\n    throw new Error(errors.INVALID_NUMBER_OF_PERIOD);\n  }\n\n  var locations = findChildren(mpd, 'Location');\n  var mpdAttributes = parseAttributes(mpd);\n  var mpdBaseUrls = buildBaseUrls([manifestUri], findChildren(mpd, 'BaseURL')); // See DASH spec section 5.3.1.2, Semantics of MPD element. Default type to 'static'.\n\n  mpdAttributes.type = mpdAttributes.type || 'static';\n  mpdAttributes.sourceDuration = mpdAttributes.mediaPresentationDuration || 0;\n  mpdAttributes.NOW = NOW;\n  mpdAttributes.clientOffset = clientOffset;\n\n  if (locations.length) {\n    mpdAttributes.locations = locations.map(getContent);\n  }\n\n  var periods = []; // Since toAdaptationSets acts on individual periods right now, the simplest approach to\n  // adding properties that require looking at prior periods is to parse attributes and add\n  // missing ones before toAdaptationSets is called. If more such properties are added, it\n  // may be better to refactor toAdaptationSets.\n\n  periodNodes.forEach(function (node, index) {\n    var attributes = parseAttributes(node); // Use the last modified prior period, as it may contain added information necessary\n    // for this period.\n\n    var priorPeriod = periods[index - 1];\n    attributes.start = getPeriodStart({\n      attributes: attributes,\n      priorPeriodAttributes: priorPeriod ? priorPeriod.attributes : null,\n      mpdType: mpdAttributes.type\n    });\n    periods.push({\n      node: node,\n      attributes: attributes\n    });\n  });\n  return {\n    locations: mpdAttributes.locations,\n    representationInfo: flatten(periods.map(toAdaptationSets(mpdAttributes, mpdBaseUrls)))\n  };\n};\n\nvar stringToMpdXml = function stringToMpdXml(manifestString) {\n  if (manifestString === '') {\n    throw new Error(errors.DASH_EMPTY_MANIFEST);\n  }\n\n  var parser = new DOMParser();\n  var xml;\n  var mpd;\n\n  try {\n    xml = parser.parseFromString(manifestString, 'application/xml');\n    mpd = xml && xml.documentElement.tagName === 'MPD' ? xml.documentElement : null;\n  } catch (e) {// ie 11 throwsw on invalid xml\n  }\n\n  if (!mpd || mpd && mpd.getElementsByTagName('parsererror').length > 0) {\n    throw new Error(errors.DASH_INVALID_XML);\n  }\n\n  return mpd;\n};\n/**\n * Parses the manifest for a UTCTiming node, returning the nodes attributes if found\n *\n * @param {string} mpd\n *        XML string of the MPD manifest\n * @return {Object|null}\n *         Attributes of UTCTiming node specified in the manifest. Null if none found\n */\n\n\nvar parseUTCTimingScheme = function parseUTCTimingScheme(mpd) {\n  var UTCTimingNode = findChildren(mpd, 'UTCTiming')[0];\n\n  if (!UTCTimingNode) {\n    return null;\n  }\n\n  var attributes = parseAttributes(UTCTimingNode);\n\n  switch (attributes.schemeIdUri) {\n    case 'urn:mpeg:dash:utc:http-head:2014':\n    case 'urn:mpeg:dash:utc:http-head:2012':\n      attributes.method = 'HEAD';\n      break;\n\n    case 'urn:mpeg:dash:utc:http-xsdate:2014':\n    case 'urn:mpeg:dash:utc:http-iso:2014':\n    case 'urn:mpeg:dash:utc:http-xsdate:2012':\n    case 'urn:mpeg:dash:utc:http-iso:2012':\n      attributes.method = 'GET';\n      break;\n\n    case 'urn:mpeg:dash:utc:direct:2014':\n    case 'urn:mpeg:dash:utc:direct:2012':\n      attributes.method = 'DIRECT';\n      attributes.value = Date.parse(attributes.value);\n      break;\n\n    case 'urn:mpeg:dash:utc:http-ntp:2014':\n    case 'urn:mpeg:dash:utc:ntp:2014':\n    case 'urn:mpeg:dash:utc:sntp:2014':\n    default:\n      throw new Error(errors.UNSUPPORTED_UTC_TIMING_SCHEME);\n  }\n\n  return attributes;\n};\n\nvar VERSION = version;\n/*\n * Given a DASH manifest string and options, parses the DASH manifest into an object in the\n * form outputed by m3u8-parser and accepted by videojs/http-streaming.\n *\n * For live DASH manifests, if `previousManifest` is provided in options, then the newly\n * parsed DASH manifest will have its media sequence and discontinuity sequence values\n * updated to reflect its position relative to the prior manifest.\n *\n * @param {string} manifestString - the DASH manifest as a string\n * @param {options} [options] - any options\n *\n * @return {Object} the manifest object\n */\n\nvar parse = function parse(manifestString, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var parsedManifestInfo = inheritAttributes(stringToMpdXml(manifestString), options);\n  var playlists = toPlaylists(parsedManifestInfo.representationInfo);\n  return toM3u8({\n    dashPlaylists: playlists,\n    locations: parsedManifestInfo.locations,\n    sidxMapping: options.sidxMapping,\n    previousManifest: options.previousManifest\n  });\n};\n/**\n * Parses the manifest for a UTCTiming node, returning the nodes attributes if found\n *\n * @param {string} manifestString\n *        XML string of the MPD manifest\n * @return {Object|null}\n *         Attributes of UTCTiming node specified in the manifest. Null if none found\n */\n\n\nvar parseUTCTiming = function parseUTCTiming(manifestString) {\n  return parseUTCTimingScheme(stringToMpdXml(manifestString));\n};\n\nexport { VERSION, addSidxSegmentsToPlaylist$1 as addSidxSegmentsToPlaylist, generateSidxKey, inheritAttributes, parse, parseUTCTiming, stringToMpdXml, toM3u8, toPlaylists };","map":{"version":3,"names":["resolveUrl","window","forEachMediaGroup","decodeB64ToUint8Array","DOMParser","version","isObject","obj","merge","_len","arguments","length","objects","Array","_key","reduce","result","source","Object","keys","forEach","key","isArray","concat","values","o","map","k","range","start","end","i","push","flatten","lists","x","y","from","list","findIndexes","l","a","e","findIndex","matchingFunction","union","keyFunction","acc","el","errors","INVALID_NUMBER_OF_PERIOD","DASH_EMPTY_MANIFEST","DASH_INVALID_XML","NO_BASE_URL","MISSING_SEGMENT_INFORMATION","SEGMENT_TIME_UNSPECIFIED","UNSUPPORTED_UTC_TIMING_SCHEME","urlTypeToSegment","_ref","_ref$baseUrl","baseUrl","_ref$source","_ref$range","_ref$indexRange","indexRange","segment","uri","resolvedUri","rangeStr","ranges","split","startRange","BigInt","parseInt","endRange","Number","MAX_SAFE_INTEGER","byterange","offset","byteRangeToString","parseEndNumber","endNumber","isNaN","segmentRange","static","_static","attributes","duration","_attributes$timescale","timescale","sourceDuration","periodDuration","segmentDuration","dynamic","NOW","clientOffset","availabilityStartTime","_attributes$timescale2","_attributes$periodSta","periodStart","_attributes$minimumUp","minimumUpdatePeriod","_attributes$timeShift","timeShiftBufferDepth","Infinity","now","periodStartWC","periodEndWC","segmentCount","Math","ceil","availableStart","floor","availableEnd","max","min","toSegments","number","_attributes$timescale3","_attributes$startNumb","startNumber","timeline","time","parseByDuration","type","_attributes$timescale4","_segmentRange$type","segments","index","sectionDuration","segmentsFromBase","_attributes$initializ","initialization","_attributes$indexRang","presentationTime","_attributes$number","Error","initSegment","sourceURL","segmentTimeInfo","addSidxSegmentsToPlaylist$1","addSidxSegmentsToPlaylist","playlist","sidx","sidxByteRange","sidxEnd","mediaReferences","references","filter","r","referenceType","endList","mediaSequence","startIndex","firstOffset","reference","size","referencedSize","subsegmentDuration","endIndex","SUPPORTED_MEDIA_TYPES","TIME_FUDGE","getUniqueTimelineStarts","timelineStarts","sort","b","findPlaylistWithName","playlists","name","NAME","getMediaGroupPlaylists","manifest","mediaGroupPlaylists","properties","group","label","updateMediaSequenceForPlaylist","_ref2","updateSequenceNumbers","_ref3","oldPlaylists","newPlaylists","discontinuitySequence","_ref4","oldPlaylist","firstNewSegment","oldMatchingSegmentIndex","oldSegment","abs","discontinuity","discontinuityStarts","unshift","oldMatchingSegment","positionManifestOnTimeline","_ref5","oldManifest","newManifest","generateSidxKey","mergeDiscontiguousPlaylists","mergedPlaylists","id","lang","_acc$name$segments","apply","contentProtection","sidxMapping","sidxKey","sidxMatch","addSidxSegmentsToPlaylists","formatAudioPlaylist","isAudioOnly","_attributes","BANDWIDTH","bandwidth","CODECS","codecs","targetDuration","AUDIO","SUBTITLES","formatVttPlaylist","_m3u8Attributes","m3u8Attributes","organizeAudioPlaylists","mainPlaylist","formattedPlaylists","role","value","language","roleLabel","autoselect","default","formatted","firstLabel","organizeVttPlaylists","organizeCaptionServices","captionServices","svcObj","svc","service","channel","instreamId","hasOwnProperty","aspectRatio","easyReader","formatVideoPlaylist","_attributes2","RESOLUTION","width","height","videoOnly","mimeType","contentType","audioOnly","vttOnly","_ref6","addMediaSequenceValues","_ref7","flattenMediaGroupPlaylists","mediaGroupObject","labelContents","toM3u8","_ref8","_mediaGroups","dashPlaylists","locations","_ref8$sidxMapping","previousManifest","_dashPlaylists$0$attr","suggestedPresentationDelay","videoPlaylists","audioPlaylists","vttPlaylists","captions","Boolean","allowCache","mediaGroups","VIDEO","organizedAudioGroup","organizedVttGroup","playlistTimelineStarts","_ref9","audio","subs","cc","getLiveRValue","parseByTimeline","segmentTimeline","_attributes$minimumUp2","_attributes$media","media","sIndex","S","d","repeat","segmentTime","t","count","nextS","indexOf","identifierPattern","identifierReplacement","match","identifier","format","join","constructTemplateUrl","url","replace","parseTemplateInfo","segmentsFromTemplate","templateValues","RepresentationID","Bandwidth","mapSegment","Time","presentationTimeOffset","SegmentURLToSegmentObject","segmentUrl","mediaRange","segmentsFromList","_attributes$segmentUr","segmentUrls","segmentUrlMap","segmentUrlObject","generateSegments","segmentInfo","segmentAttributes","segmentsFn","template","base","segmentsInfo","_segmentAttributes","_segmentAttributes$ti","toPlaylists","representations","findChildren","element","childNodes","tagName","getContent","textContent","trim","parseDuration","str","SECONDS_IN_YEAR","SECONDS_IN_MONTH","SECONDS_IN_DAY","SECONDS_IN_HOUR","SECONDS_IN_MIN","durationRegex","exec","_match$slice","slice","year","month","day","hour","minute","second","parseFloat","parseDate","dateRegex","test","Date","parse","parsers","mediaPresentationDuration","parsedValue","DEFAULT","parseAttributes","parseFn","keySystemsMap","buildBaseUrls","referenceUrls","baseUrlElements","baseUrlElement","getSegmentInformation","adaptationSet","segmentTemplate","segmentList","s","tag","segmentBase","segmentTimelineParentNode","segmentInitializationParentNode","segmentInitialization","inheritBaseUrls","adaptationSetAttributes","adaptationSetBaseUrls","adaptationSetSegmentInfo","representation","repBaseUrlElements","repBaseUrls","representationSegmentInfo","generateKeySystemInformation","contentProtectionNodes","node","schemeIdUri","toLowerCase","keySystem","psshNode","pssh","parseCaptionServiceMetadata","_value$split","_values","flags","undefined","_value$split2","_value$split2$","opts","opt","_opt$split","val","toRepresentations","periodAttributes","periodBaseUrls","periodSegmentInfo","roleAttributes","attrs","accessibility","labelVal","nodeValue","toAdaptationSets","mpdAttributes","mpdBaseUrls","period","adaptationSets","getPeriodStart","priorPeriodAttributes","mpdType","inheritAttributes","mpd","options","_options","_options$manifestUri","manifestUri","_options$NOW","_options$clientOffset","periodNodes","periods","priorPeriod","representationInfo","stringToMpdXml","manifestString","parser","xml","parseFromString","documentElement","getElementsByTagName","parseUTCTimingScheme","UTCTimingNode","method","VERSION","parsedManifestInfo","parseUTCTiming"],"sources":["C:/office/xampp/htdocs/softtech_it_landing/node_modules/mpd-parser/dist/mpd-parser.es.js"],"sourcesContent":["/*! @name mpd-parser @version 0.21.1 @license Apache-2.0 */\nimport resolveUrl from '@videojs/vhs-utils/es/resolve-url';\nimport window from 'global/window';\nimport { forEachMediaGroup } from '@videojs/vhs-utils/es/media-groups';\nimport decodeB64ToUint8Array from '@videojs/vhs-utils/es/decode-b64-to-uint8-array';\nimport { DOMParser } from '@xmldom/xmldom';\n\nvar version = \"0.21.1\";\n\nvar isObject = function isObject(obj) {\n  return !!obj && typeof obj === 'object';\n};\n\nvar merge = function merge() {\n  for (var _len = arguments.length, objects = new Array(_len), _key = 0; _key < _len; _key++) {\n    objects[_key] = arguments[_key];\n  }\n\n  return objects.reduce(function (result, source) {\n    if (typeof source !== 'object') {\n      return result;\n    }\n\n    Object.keys(source).forEach(function (key) {\n      if (Array.isArray(result[key]) && Array.isArray(source[key])) {\n        result[key] = result[key].concat(source[key]);\n      } else if (isObject(result[key]) && isObject(source[key])) {\n        result[key] = merge(result[key], source[key]);\n      } else {\n        result[key] = source[key];\n      }\n    });\n    return result;\n  }, {});\n};\nvar values = function values(o) {\n  return Object.keys(o).map(function (k) {\n    return o[k];\n  });\n};\n\nvar range = function range(start, end) {\n  var result = [];\n\n  for (var i = start; i < end; i++) {\n    result.push(i);\n  }\n\n  return result;\n};\nvar flatten = function flatten(lists) {\n  return lists.reduce(function (x, y) {\n    return x.concat(y);\n  }, []);\n};\nvar from = function from(list) {\n  if (!list.length) {\n    return [];\n  }\n\n  var result = [];\n\n  for (var i = 0; i < list.length; i++) {\n    result.push(list[i]);\n  }\n\n  return result;\n};\nvar findIndexes = function findIndexes(l, key) {\n  return l.reduce(function (a, e, i) {\n    if (e[key]) {\n      a.push(i);\n    }\n\n    return a;\n  }, []);\n};\n/**\n * Returns the first index that satisfies the matching function, or -1 if not found.\n *\n * Only necessary because of IE11 support.\n *\n * @param {Array} list - the list to search through\n * @param {Function} matchingFunction - the matching function\n *\n * @return {number} the matching index or -1 if not found\n */\n\nvar findIndex = function findIndex(list, matchingFunction) {\n  for (var i = 0; i < list.length; i++) {\n    if (matchingFunction(list[i])) {\n      return i;\n    }\n  }\n\n  return -1;\n};\n/**\n * Returns a union of the included lists provided each element can be identified by a key.\n *\n * @param {Array} list - list of lists to get the union of\n * @param {Function} keyFunction - the function to use as a key for each element\n *\n * @return {Array} the union of the arrays\n */\n\nvar union = function union(lists, keyFunction) {\n  return values(lists.reduce(function (acc, list) {\n    list.forEach(function (el) {\n      acc[keyFunction(el)] = el;\n    });\n    return acc;\n  }, {}));\n};\n\nvar errors = {\n  INVALID_NUMBER_OF_PERIOD: 'INVALID_NUMBER_OF_PERIOD',\n  DASH_EMPTY_MANIFEST: 'DASH_EMPTY_MANIFEST',\n  DASH_INVALID_XML: 'DASH_INVALID_XML',\n  NO_BASE_URL: 'NO_BASE_URL',\n  MISSING_SEGMENT_INFORMATION: 'MISSING_SEGMENT_INFORMATION',\n  SEGMENT_TIME_UNSPECIFIED: 'SEGMENT_TIME_UNSPECIFIED',\n  UNSUPPORTED_UTC_TIMING_SCHEME: 'UNSUPPORTED_UTC_TIMING_SCHEME'\n};\n\n/**\n * @typedef {Object} SingleUri\n * @property {string} uri - relative location of segment\n * @property {string} resolvedUri - resolved location of segment\n * @property {Object} byterange - Object containing information on how to make byte range\n *   requests following byte-range-spec per RFC2616.\n * @property {String} byterange.length - length of range request\n * @property {String} byterange.offset - byte offset of range request\n *\n * @see https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.35.1\n */\n\n/**\n * Converts a URLType node (5.3.9.2.3 Table 13) to a segment object\n * that conforms to how m3u8-parser is structured\n *\n * @see https://github.com/videojs/m3u8-parser\n *\n * @param {string} baseUrl - baseUrl provided by <BaseUrl> nodes\n * @param {string} source - source url for segment\n * @param {string} range - optional range used for range calls,\n *   follows  RFC 2616, Clause 14.35.1\n * @return {SingleUri} full segment information transformed into a format similar\n *   to m3u8-parser\n */\n\nvar urlTypeToSegment = function urlTypeToSegment(_ref) {\n  var _ref$baseUrl = _ref.baseUrl,\n      baseUrl = _ref$baseUrl === void 0 ? '' : _ref$baseUrl,\n      _ref$source = _ref.source,\n      source = _ref$source === void 0 ? '' : _ref$source,\n      _ref$range = _ref.range,\n      range = _ref$range === void 0 ? '' : _ref$range,\n      _ref$indexRange = _ref.indexRange,\n      indexRange = _ref$indexRange === void 0 ? '' : _ref$indexRange;\n  var segment = {\n    uri: source,\n    resolvedUri: resolveUrl(baseUrl || '', source)\n  };\n\n  if (range || indexRange) {\n    var rangeStr = range ? range : indexRange;\n    var ranges = rangeStr.split('-'); // default to parsing this as a BigInt if possible\n\n    var startRange = window.BigInt ? window.BigInt(ranges[0]) : parseInt(ranges[0], 10);\n    var endRange = window.BigInt ? window.BigInt(ranges[1]) : parseInt(ranges[1], 10); // convert back to a number if less than MAX_SAFE_INTEGER\n\n    if (startRange < Number.MAX_SAFE_INTEGER && typeof startRange === 'bigint') {\n      startRange = Number(startRange);\n    }\n\n    if (endRange < Number.MAX_SAFE_INTEGER && typeof endRange === 'bigint') {\n      endRange = Number(endRange);\n    }\n\n    var length;\n\n    if (typeof endRange === 'bigint' || typeof startRange === 'bigint') {\n      length = window.BigInt(endRange) - window.BigInt(startRange) + window.BigInt(1);\n    } else {\n      length = endRange - startRange + 1;\n    }\n\n    if (typeof length === 'bigint' && length < Number.MAX_SAFE_INTEGER) {\n      length = Number(length);\n    } // byterange should be inclusive according to\n    // RFC 2616, Clause 14.35.1\n\n\n    segment.byterange = {\n      length: length,\n      offset: startRange\n    };\n  }\n\n  return segment;\n};\nvar byteRangeToString = function byteRangeToString(byterange) {\n  // `endRange` is one less than `offset + length` because the HTTP range\n  // header uses inclusive ranges\n  var endRange;\n\n  if (typeof byterange.offset === 'bigint' || typeof byterange.length === 'bigint') {\n    endRange = window.BigInt(byterange.offset) + window.BigInt(byterange.length) - window.BigInt(1);\n  } else {\n    endRange = byterange.offset + byterange.length - 1;\n  }\n\n  return byterange.offset + \"-\" + endRange;\n};\n\n/**\n * parse the end number attribue that can be a string\n * number, or undefined.\n *\n * @param {string|number|undefined} endNumber\n *        The end number attribute.\n *\n * @return {number|null}\n *          The result of parsing the end number.\n */\n\nvar parseEndNumber = function parseEndNumber(endNumber) {\n  if (endNumber && typeof endNumber !== 'number') {\n    endNumber = parseInt(endNumber, 10);\n  }\n\n  if (isNaN(endNumber)) {\n    return null;\n  }\n\n  return endNumber;\n};\n/**\n * Functions for calculating the range of available segments in static and dynamic\n * manifests.\n */\n\n\nvar segmentRange = {\n  /**\n   * Returns the entire range of available segments for a static MPD\n   *\n   * @param {Object} attributes\n   *        Inheritied MPD attributes\n   * @return {{ start: number, end: number }}\n   *         The start and end numbers for available segments\n   */\n  static: function _static(attributes) {\n    var duration = attributes.duration,\n        _attributes$timescale = attributes.timescale,\n        timescale = _attributes$timescale === void 0 ? 1 : _attributes$timescale,\n        sourceDuration = attributes.sourceDuration,\n        periodDuration = attributes.periodDuration;\n    var endNumber = parseEndNumber(attributes.endNumber);\n    var segmentDuration = duration / timescale;\n\n    if (typeof endNumber === 'number') {\n      return {\n        start: 0,\n        end: endNumber\n      };\n    }\n\n    if (typeof periodDuration === 'number') {\n      return {\n        start: 0,\n        end: periodDuration / segmentDuration\n      };\n    }\n\n    return {\n      start: 0,\n      end: sourceDuration / segmentDuration\n    };\n  },\n\n  /**\n   * Returns the current live window range of available segments for a dynamic MPD\n   *\n   * @param {Object} attributes\n   *        Inheritied MPD attributes\n   * @return {{ start: number, end: number }}\n   *         The start and end numbers for available segments\n   */\n  dynamic: function dynamic(attributes) {\n    var NOW = attributes.NOW,\n        clientOffset = attributes.clientOffset,\n        availabilityStartTime = attributes.availabilityStartTime,\n        _attributes$timescale2 = attributes.timescale,\n        timescale = _attributes$timescale2 === void 0 ? 1 : _attributes$timescale2,\n        duration = attributes.duration,\n        _attributes$periodSta = attributes.periodStart,\n        periodStart = _attributes$periodSta === void 0 ? 0 : _attributes$periodSta,\n        _attributes$minimumUp = attributes.minimumUpdatePeriod,\n        minimumUpdatePeriod = _attributes$minimumUp === void 0 ? 0 : _attributes$minimumUp,\n        _attributes$timeShift = attributes.timeShiftBufferDepth,\n        timeShiftBufferDepth = _attributes$timeShift === void 0 ? Infinity : _attributes$timeShift;\n    var endNumber = parseEndNumber(attributes.endNumber); // clientOffset is passed in at the top level of mpd-parser and is an offset calculated\n    // after retrieving UTC server time.\n\n    var now = (NOW + clientOffset) / 1000; // WC stands for Wall Clock.\n    // Convert the period start time to EPOCH.\n\n    var periodStartWC = availabilityStartTime + periodStart; // Period end in EPOCH is manifest's retrieval time + time until next update.\n\n    var periodEndWC = now + minimumUpdatePeriod;\n    var periodDuration = periodEndWC - periodStartWC;\n    var segmentCount = Math.ceil(periodDuration * timescale / duration);\n    var availableStart = Math.floor((now - periodStartWC - timeShiftBufferDepth) * timescale / duration);\n    var availableEnd = Math.floor((now - periodStartWC) * timescale / duration);\n    return {\n      start: Math.max(0, availableStart),\n      end: typeof endNumber === 'number' ? endNumber : Math.min(segmentCount, availableEnd)\n    };\n  }\n};\n/**\n * Maps a range of numbers to objects with information needed to build the corresponding\n * segment list\n *\n * @name toSegmentsCallback\n * @function\n * @param {number} number\n *        Number of the segment\n * @param {number} index\n *        Index of the number in the range list\n * @return {{ number: Number, duration: Number, timeline: Number, time: Number }}\n *         Object with segment timing and duration info\n */\n\n/**\n * Returns a callback for Array.prototype.map for mapping a range of numbers to\n * information needed to build the segment list.\n *\n * @param {Object} attributes\n *        Inherited MPD attributes\n * @return {toSegmentsCallback}\n *         Callback map function\n */\n\nvar toSegments = function toSegments(attributes) {\n  return function (number) {\n    var duration = attributes.duration,\n        _attributes$timescale3 = attributes.timescale,\n        timescale = _attributes$timescale3 === void 0 ? 1 : _attributes$timescale3,\n        periodStart = attributes.periodStart,\n        _attributes$startNumb = attributes.startNumber,\n        startNumber = _attributes$startNumb === void 0 ? 1 : _attributes$startNumb;\n    return {\n      number: startNumber + number,\n      duration: duration / timescale,\n      timeline: periodStart,\n      time: number * duration\n    };\n  };\n};\n/**\n * Returns a list of objects containing segment timing and duration info used for\n * building the list of segments. This uses the @duration attribute specified\n * in the MPD manifest to derive the range of segments.\n *\n * @param {Object} attributes\n *        Inherited MPD attributes\n * @return {{number: number, duration: number, time: number, timeline: number}[]}\n *         List of Objects with segment timing and duration info\n */\n\nvar parseByDuration = function parseByDuration(attributes) {\n  var type = attributes.type,\n      duration = attributes.duration,\n      _attributes$timescale4 = attributes.timescale,\n      timescale = _attributes$timescale4 === void 0 ? 1 : _attributes$timescale4,\n      periodDuration = attributes.periodDuration,\n      sourceDuration = attributes.sourceDuration;\n\n  var _segmentRange$type = segmentRange[type](attributes),\n      start = _segmentRange$type.start,\n      end = _segmentRange$type.end;\n\n  var segments = range(start, end).map(toSegments(attributes));\n\n  if (type === 'static') {\n    var index = segments.length - 1; // section is either a period or the full source\n\n    var sectionDuration = typeof periodDuration === 'number' ? periodDuration : sourceDuration; // final segment may be less than full segment duration\n\n    segments[index].duration = sectionDuration - duration / timescale * index;\n  }\n\n  return segments;\n};\n\n/**\n * Translates SegmentBase into a set of segments.\n * (DASH SPEC Section 5.3.9.3.2) contains a set of <SegmentURL> nodes.  Each\n * node should be translated into segment.\n *\n * @param {Object} attributes\n *   Object containing all inherited attributes from parent elements with attribute\n *   names as keys\n * @return {Object.<Array>} list of segments\n */\n\nvar segmentsFromBase = function segmentsFromBase(attributes) {\n  var baseUrl = attributes.baseUrl,\n      _attributes$initializ = attributes.initialization,\n      initialization = _attributes$initializ === void 0 ? {} : _attributes$initializ,\n      sourceDuration = attributes.sourceDuration,\n      _attributes$indexRang = attributes.indexRange,\n      indexRange = _attributes$indexRang === void 0 ? '' : _attributes$indexRang,\n      periodStart = attributes.periodStart,\n      presentationTime = attributes.presentationTime,\n      _attributes$number = attributes.number,\n      number = _attributes$number === void 0 ? 0 : _attributes$number,\n      duration = attributes.duration; // base url is required for SegmentBase to work, per spec (Section 5.3.9.2.1)\n\n  if (!baseUrl) {\n    throw new Error(errors.NO_BASE_URL);\n  }\n\n  var initSegment = urlTypeToSegment({\n    baseUrl: baseUrl,\n    source: initialization.sourceURL,\n    range: initialization.range\n  });\n  var segment = urlTypeToSegment({\n    baseUrl: baseUrl,\n    source: baseUrl,\n    indexRange: indexRange\n  });\n  segment.map = initSegment; // If there is a duration, use it, otherwise use the given duration of the source\n  // (since SegmentBase is only for one total segment)\n\n  if (duration) {\n    var segmentTimeInfo = parseByDuration(attributes);\n\n    if (segmentTimeInfo.length) {\n      segment.duration = segmentTimeInfo[0].duration;\n      segment.timeline = segmentTimeInfo[0].timeline;\n    }\n  } else if (sourceDuration) {\n    segment.duration = sourceDuration;\n    segment.timeline = periodStart;\n  } // If presentation time is provided, these segments are being generated by SIDX\n  // references, and should use the time provided. For the general case of SegmentBase,\n  // there should only be one segment in the period, so its presentation time is the same\n  // as its period start.\n\n\n  segment.presentationTime = presentationTime || periodStart;\n  segment.number = number;\n  return [segment];\n};\n/**\n * Given a playlist, a sidx box, and a baseUrl, update the segment list of the playlist\n * according to the sidx information given.\n *\n * playlist.sidx has metadadata about the sidx where-as the sidx param\n * is the parsed sidx box itself.\n *\n * @param {Object} playlist the playlist to update the sidx information for\n * @param {Object} sidx the parsed sidx box\n * @return {Object} the playlist object with the updated sidx information\n */\n\nvar addSidxSegmentsToPlaylist$1 = function addSidxSegmentsToPlaylist(playlist, sidx, baseUrl) {\n  // Retain init segment information\n  var initSegment = playlist.sidx.map ? playlist.sidx.map : null; // Retain source duration from initial main manifest parsing\n\n  var sourceDuration = playlist.sidx.duration; // Retain source timeline\n\n  var timeline = playlist.timeline || 0;\n  var sidxByteRange = playlist.sidx.byterange;\n  var sidxEnd = sidxByteRange.offset + sidxByteRange.length; // Retain timescale of the parsed sidx\n\n  var timescale = sidx.timescale; // referenceType 1 refers to other sidx boxes\n\n  var mediaReferences = sidx.references.filter(function (r) {\n    return r.referenceType !== 1;\n  });\n  var segments = [];\n  var type = playlist.endList ? 'static' : 'dynamic';\n  var periodStart = playlist.sidx.timeline;\n  var presentationTime = periodStart;\n  var number = playlist.mediaSequence || 0; // firstOffset is the offset from the end of the sidx box\n\n  var startIndex; // eslint-disable-next-line\n\n  if (typeof sidx.firstOffset === 'bigint') {\n    startIndex = window.BigInt(sidxEnd) + sidx.firstOffset;\n  } else {\n    startIndex = sidxEnd + sidx.firstOffset;\n  }\n\n  for (var i = 0; i < mediaReferences.length; i++) {\n    var reference = sidx.references[i]; // size of the referenced (sub)segment\n\n    var size = reference.referencedSize; // duration of the referenced (sub)segment, in  the  timescale\n    // this will be converted to seconds when generating segments\n\n    var duration = reference.subsegmentDuration; // should be an inclusive range\n\n    var endIndex = void 0; // eslint-disable-next-line\n\n    if (typeof startIndex === 'bigint') {\n      endIndex = startIndex + window.BigInt(size) - window.BigInt(1);\n    } else {\n      endIndex = startIndex + size - 1;\n    }\n\n    var indexRange = startIndex + \"-\" + endIndex;\n    var attributes = {\n      baseUrl: baseUrl,\n      timescale: timescale,\n      timeline: timeline,\n      periodStart: periodStart,\n      presentationTime: presentationTime,\n      number: number,\n      duration: duration,\n      sourceDuration: sourceDuration,\n      indexRange: indexRange,\n      type: type\n    };\n    var segment = segmentsFromBase(attributes)[0];\n\n    if (initSegment) {\n      segment.map = initSegment;\n    }\n\n    segments.push(segment);\n\n    if (typeof startIndex === 'bigint') {\n      startIndex += window.BigInt(size);\n    } else {\n      startIndex += size;\n    }\n\n    presentationTime += duration / timescale;\n    number++;\n  }\n\n  playlist.segments = segments;\n  return playlist;\n};\n\nvar SUPPORTED_MEDIA_TYPES = ['AUDIO', 'SUBTITLES']; // allow one 60fps frame as leniency (arbitrarily chosen)\n\nvar TIME_FUDGE = 1 / 60;\n/**\n * Given a list of timelineStarts, combines, dedupes, and sorts them.\n *\n * @param {TimelineStart[]} timelineStarts - list of timeline starts\n *\n * @return {TimelineStart[]} the combined and deduped timeline starts\n */\n\nvar getUniqueTimelineStarts = function getUniqueTimelineStarts(timelineStarts) {\n  return union(timelineStarts, function (_ref) {\n    var timeline = _ref.timeline;\n    return timeline;\n  }).sort(function (a, b) {\n    return a.timeline > b.timeline ? 1 : -1;\n  });\n};\n/**\n * Finds the playlist with the matching NAME attribute.\n *\n * @param {Array} playlists - playlists to search through\n * @param {string} name - the NAME attribute to search for\n *\n * @return {Object|null} the matching playlist object, or null\n */\n\nvar findPlaylistWithName = function findPlaylistWithName(playlists, name) {\n  for (var i = 0; i < playlists.length; i++) {\n    if (playlists[i].attributes.NAME === name) {\n      return playlists[i];\n    }\n  }\n\n  return null;\n};\n/**\n * Gets a flattened array of media group playlists.\n *\n * @param {Object} manifest - the main manifest object\n *\n * @return {Array} the media group playlists\n */\n\nvar getMediaGroupPlaylists = function getMediaGroupPlaylists(manifest) {\n  var mediaGroupPlaylists = [];\n  forEachMediaGroup(manifest, SUPPORTED_MEDIA_TYPES, function (properties, type, group, label) {\n    mediaGroupPlaylists = mediaGroupPlaylists.concat(properties.playlists || []);\n  });\n  return mediaGroupPlaylists;\n};\n/**\n * Updates the playlist's media sequence numbers.\n *\n * @param {Object} config - options object\n * @param {Object} config.playlist - the playlist to update\n * @param {number} config.mediaSequence - the mediaSequence number to start with\n */\n\nvar updateMediaSequenceForPlaylist = function updateMediaSequenceForPlaylist(_ref2) {\n  var playlist = _ref2.playlist,\n      mediaSequence = _ref2.mediaSequence;\n  playlist.mediaSequence = mediaSequence;\n  playlist.segments.forEach(function (segment, index) {\n    segment.number = playlist.mediaSequence + index;\n  });\n};\n/**\n * Updates the media and discontinuity sequence numbers of newPlaylists given oldPlaylists\n * and a complete list of timeline starts.\n *\n * If no matching playlist is found, only the discontinuity sequence number of the playlist\n * will be updated.\n *\n * Since early available timelines are not supported, at least one segment must be present.\n *\n * @param {Object} config - options object\n * @param {Object[]} oldPlaylists - the old playlists to use as a reference\n * @param {Object[]} newPlaylists - the new playlists to update\n * @param {Object} timelineStarts - all timelineStarts seen in the stream to this point\n */\n\nvar updateSequenceNumbers = function updateSequenceNumbers(_ref3) {\n  var oldPlaylists = _ref3.oldPlaylists,\n      newPlaylists = _ref3.newPlaylists,\n      timelineStarts = _ref3.timelineStarts;\n  newPlaylists.forEach(function (playlist) {\n    playlist.discontinuitySequence = findIndex(timelineStarts, function (_ref4) {\n      var timeline = _ref4.timeline;\n      return timeline === playlist.timeline;\n    }); // Playlists NAMEs come from DASH Representation IDs, which are mandatory\n    // (see ISO_23009-1-2012 5.3.5.2).\n    //\n    // If the same Representation existed in a prior Period, it will retain the same NAME.\n\n    var oldPlaylist = findPlaylistWithName(oldPlaylists, playlist.attributes.NAME);\n\n    if (!oldPlaylist) {\n      // Since this is a new playlist, the media sequence values can start from 0 without\n      // consequence.\n      return;\n    } // TODO better support for live SIDX\n    //\n    // As of this writing, mpd-parser does not support multiperiod SIDX (in live or VOD).\n    // This is evident by a playlist only having a single SIDX reference. In a multiperiod\n    // playlist there would need to be multiple SIDX references. In addition, live SIDX is\n    // not supported when the SIDX properties change on refreshes.\n    //\n    // In the future, if support needs to be added, the merging logic here can be called\n    // after SIDX references are resolved. For now, exit early to prevent exceptions being\n    // thrown due to undefined references.\n\n\n    if (playlist.sidx) {\n      return;\n    } // Since we don't yet support early available timelines, we don't need to support\n    // playlists with no segments.\n\n\n    var firstNewSegment = playlist.segments[0];\n    var oldMatchingSegmentIndex = findIndex(oldPlaylist.segments, function (oldSegment) {\n      return Math.abs(oldSegment.presentationTime - firstNewSegment.presentationTime) < TIME_FUDGE;\n    }); // No matching segment from the old playlist means the entire playlist was refreshed.\n    // In this case the media sequence should account for this update, and the new segments\n    // should be marked as discontinuous from the prior content, since the last prior\n    // timeline was removed.\n\n    if (oldMatchingSegmentIndex === -1) {\n      updateMediaSequenceForPlaylist({\n        playlist: playlist,\n        mediaSequence: oldPlaylist.mediaSequence + oldPlaylist.segments.length\n      });\n      playlist.segments[0].discontinuity = true;\n      playlist.discontinuityStarts.unshift(0); // No matching segment does not necessarily mean there's missing content.\n      //\n      // If the new playlist's timeline is the same as the last seen segment's timeline,\n      // then a discontinuity can be added to identify that there's potentially missing\n      // content. If there's no missing content, the discontinuity should still be rather\n      // harmless. It's possible that if segment durations are accurate enough, that the\n      // existence of a gap can be determined using the presentation times and durations,\n      // but if the segment timing info is off, it may introduce more problems than simply\n      // adding the discontinuity.\n      //\n      // If the new playlist's timeline is different from the last seen segment's timeline,\n      // then a discontinuity can be added to identify that this is the first seen segment\n      // of a new timeline. However, the logic at the start of this function that\n      // determined the disconinuity sequence by timeline index is now off by one (the\n      // discontinuity of the newest timeline hasn't yet fallen off the manifest...since\n      // we added it), so the disconinuity sequence must be decremented.\n      //\n      // A period may also have a duration of zero, so the case of no segments is handled\n      // here even though we don't yet support early available periods.\n\n      if (!oldPlaylist.segments.length && playlist.timeline > oldPlaylist.timeline || oldPlaylist.segments.length && playlist.timeline > oldPlaylist.segments[oldPlaylist.segments.length - 1].timeline) {\n        playlist.discontinuitySequence--;\n      }\n\n      return;\n    } // If the first segment matched with a prior segment on a discontinuity (it's matching\n    // on the first segment of a period), then the discontinuitySequence shouldn't be the\n    // timeline's matching one, but instead should be the one prior, and the first segment\n    // of the new manifest should be marked with a discontinuity.\n    //\n    // The reason for this special case is that discontinuity sequence shows how many\n    // discontinuities have fallen off of the playlist, and discontinuities are marked on\n    // the first segment of a new \"timeline.\" Because of this, while DASH will retain that\n    // Period while the \"timeline\" exists, HLS keeps track of it via the discontinuity\n    // sequence, and that first segment is an indicator, but can be removed before that\n    // timeline is gone.\n\n\n    var oldMatchingSegment = oldPlaylist.segments[oldMatchingSegmentIndex];\n\n    if (oldMatchingSegment.discontinuity && !firstNewSegment.discontinuity) {\n      firstNewSegment.discontinuity = true;\n      playlist.discontinuityStarts.unshift(0);\n      playlist.discontinuitySequence--;\n    }\n\n    updateMediaSequenceForPlaylist({\n      playlist: playlist,\n      mediaSequence: oldPlaylist.segments[oldMatchingSegmentIndex].number\n    });\n  });\n};\n/**\n * Given an old parsed manifest object and a new parsed manifest object, updates the\n * sequence and timing values within the new manifest to ensure that it lines up with the\n * old.\n *\n * @param {Array} oldManifest - the old main manifest object\n * @param {Array} newManifest - the new main manifest object\n *\n * @return {Object} the updated new manifest object\n */\n\nvar positionManifestOnTimeline = function positionManifestOnTimeline(_ref5) {\n  var oldManifest = _ref5.oldManifest,\n      newManifest = _ref5.newManifest;\n  // Starting from v4.1.2 of the IOP, section 4.4.3.3 states:\n  //\n  // \"MPD@availabilityStartTime and Period@start shall not be changed over MPD updates.\"\n  //\n  // This was added from https://github.com/Dash-Industry-Forum/DASH-IF-IOP/issues/160\n  //\n  // Because of this change, and the difficulty of supporting periods with changing start\n  // times, periods with changing start times are not supported. This makes the logic much\n  // simpler, since periods with the same start time can be considerred the same period\n  // across refreshes.\n  //\n  // To give an example as to the difficulty of handling periods where the start time may\n  // change, if a single period manifest is refreshed with another manifest with a single\n  // period, and both the start and end times are increased, then the only way to determine\n  // if it's a new period or an old one that has changed is to look through the segments of\n  // each playlist and determine the presentation time bounds to find a match. In addition,\n  // if the period start changed to exceed the old period end, then there would be no\n  // match, and it would not be possible to determine whether the refreshed period is a new\n  // one or the old one.\n  var oldPlaylists = oldManifest.playlists.concat(getMediaGroupPlaylists(oldManifest));\n  var newPlaylists = newManifest.playlists.concat(getMediaGroupPlaylists(newManifest)); // Save all seen timelineStarts to the new manifest. Although this potentially means that\n  // there's a \"memory leak\" in that it will never stop growing, in reality, only a couple\n  // of properties are saved for each seen Period. Even long running live streams won't\n  // generate too many Periods, unless the stream is watched for decades. In the future,\n  // this can be optimized by mapping to discontinuity sequence numbers for each timeline,\n  // but it may not become an issue, and the additional info can be useful for debugging.\n\n  newManifest.timelineStarts = getUniqueTimelineStarts([oldManifest.timelineStarts, newManifest.timelineStarts]);\n  updateSequenceNumbers({\n    oldPlaylists: oldPlaylists,\n    newPlaylists: newPlaylists,\n    timelineStarts: newManifest.timelineStarts\n  });\n  return newManifest;\n};\n\nvar generateSidxKey = function generateSidxKey(sidx) {\n  return sidx && sidx.uri + '-' + byteRangeToString(sidx.byterange);\n};\n\nvar mergeDiscontiguousPlaylists = function mergeDiscontiguousPlaylists(playlists) {\n  var mergedPlaylists = values(playlists.reduce(function (acc, playlist) {\n    // assuming playlist IDs are the same across periods\n    // TODO: handle multiperiod where representation sets are not the same\n    // across periods\n    var name = playlist.attributes.id + (playlist.attributes.lang || '');\n\n    if (!acc[name]) {\n      // First Period\n      acc[name] = playlist;\n      acc[name].attributes.timelineStarts = [];\n    } else {\n      // Subsequent Periods\n      if (playlist.segments) {\n        var _acc$name$segments;\n\n        // first segment of subsequent periods signal a discontinuity\n        if (playlist.segments[0]) {\n          playlist.segments[0].discontinuity = true;\n        }\n\n        (_acc$name$segments = acc[name].segments).push.apply(_acc$name$segments, playlist.segments);\n      } // bubble up contentProtection, this assumes all DRM content\n      // has the same contentProtection\n\n\n      if (playlist.attributes.contentProtection) {\n        acc[name].attributes.contentProtection = playlist.attributes.contentProtection;\n      }\n    }\n\n    acc[name].attributes.timelineStarts.push({\n      // Although they represent the same number, it's important to have both to make it\n      // compatible with HLS potentially having a similar attribute.\n      start: playlist.attributes.periodStart,\n      timeline: playlist.attributes.periodStart\n    });\n    return acc;\n  }, {}));\n  return mergedPlaylists.map(function (playlist) {\n    playlist.discontinuityStarts = findIndexes(playlist.segments || [], 'discontinuity');\n    return playlist;\n  });\n};\n\nvar addSidxSegmentsToPlaylist = function addSidxSegmentsToPlaylist(playlist, sidxMapping) {\n  var sidxKey = generateSidxKey(playlist.sidx);\n  var sidxMatch = sidxKey && sidxMapping[sidxKey] && sidxMapping[sidxKey].sidx;\n\n  if (sidxMatch) {\n    addSidxSegmentsToPlaylist$1(playlist, sidxMatch, playlist.sidx.resolvedUri);\n  }\n\n  return playlist;\n};\nvar addSidxSegmentsToPlaylists = function addSidxSegmentsToPlaylists(playlists, sidxMapping) {\n  if (sidxMapping === void 0) {\n    sidxMapping = {};\n  }\n\n  if (!Object.keys(sidxMapping).length) {\n    return playlists;\n  }\n\n  for (var i in playlists) {\n    playlists[i] = addSidxSegmentsToPlaylist(playlists[i], sidxMapping);\n  }\n\n  return playlists;\n};\nvar formatAudioPlaylist = function formatAudioPlaylist(_ref, isAudioOnly) {\n  var _attributes;\n\n  var attributes = _ref.attributes,\n      segments = _ref.segments,\n      sidx = _ref.sidx,\n      mediaSequence = _ref.mediaSequence,\n      discontinuitySequence = _ref.discontinuitySequence,\n      discontinuityStarts = _ref.discontinuityStarts;\n  var playlist = {\n    attributes: (_attributes = {\n      NAME: attributes.id,\n      BANDWIDTH: attributes.bandwidth,\n      CODECS: attributes.codecs\n    }, _attributes['PROGRAM-ID'] = 1, _attributes),\n    uri: '',\n    endList: attributes.type === 'static',\n    timeline: attributes.periodStart,\n    resolvedUri: '',\n    targetDuration: attributes.duration,\n    discontinuitySequence: discontinuitySequence,\n    discontinuityStarts: discontinuityStarts,\n    timelineStarts: attributes.timelineStarts,\n    mediaSequence: mediaSequence,\n    segments: segments\n  };\n\n  if (attributes.contentProtection) {\n    playlist.contentProtection = attributes.contentProtection;\n  }\n\n  if (sidx) {\n    playlist.sidx = sidx;\n  }\n\n  if (isAudioOnly) {\n    playlist.attributes.AUDIO = 'audio';\n    playlist.attributes.SUBTITLES = 'subs';\n  }\n\n  return playlist;\n};\nvar formatVttPlaylist = function formatVttPlaylist(_ref2) {\n  var _m3u8Attributes;\n\n  var attributes = _ref2.attributes,\n      segments = _ref2.segments,\n      mediaSequence = _ref2.mediaSequence,\n      discontinuityStarts = _ref2.discontinuityStarts,\n      discontinuitySequence = _ref2.discontinuitySequence;\n\n  if (typeof segments === 'undefined') {\n    // vtt tracks may use single file in BaseURL\n    segments = [{\n      uri: attributes.baseUrl,\n      timeline: attributes.periodStart,\n      resolvedUri: attributes.baseUrl || '',\n      duration: attributes.sourceDuration,\n      number: 0\n    }]; // targetDuration should be the same duration as the only segment\n\n    attributes.duration = attributes.sourceDuration;\n  }\n\n  var m3u8Attributes = (_m3u8Attributes = {\n    NAME: attributes.id,\n    BANDWIDTH: attributes.bandwidth\n  }, _m3u8Attributes['PROGRAM-ID'] = 1, _m3u8Attributes);\n\n  if (attributes.codecs) {\n    m3u8Attributes.CODECS = attributes.codecs;\n  }\n\n  return {\n    attributes: m3u8Attributes,\n    uri: '',\n    endList: attributes.type === 'static',\n    timeline: attributes.periodStart,\n    resolvedUri: attributes.baseUrl || '',\n    targetDuration: attributes.duration,\n    timelineStarts: attributes.timelineStarts,\n    discontinuityStarts: discontinuityStarts,\n    discontinuitySequence: discontinuitySequence,\n    mediaSequence: mediaSequence,\n    segments: segments\n  };\n};\nvar organizeAudioPlaylists = function organizeAudioPlaylists(playlists, sidxMapping, isAudioOnly) {\n  if (sidxMapping === void 0) {\n    sidxMapping = {};\n  }\n\n  if (isAudioOnly === void 0) {\n    isAudioOnly = false;\n  }\n\n  var mainPlaylist;\n  var formattedPlaylists = playlists.reduce(function (a, playlist) {\n    var role = playlist.attributes.role && playlist.attributes.role.value || '';\n    var language = playlist.attributes.lang || '';\n    var label = playlist.attributes.label || 'main';\n\n    if (language && !playlist.attributes.label) {\n      var roleLabel = role ? \" (\" + role + \")\" : '';\n      label = \"\" + playlist.attributes.lang + roleLabel;\n    }\n\n    if (!a[label]) {\n      a[label] = {\n        language: language,\n        autoselect: true,\n        default: role === 'main',\n        playlists: [],\n        uri: ''\n      };\n    }\n\n    var formatted = addSidxSegmentsToPlaylist(formatAudioPlaylist(playlist, isAudioOnly), sidxMapping);\n    a[label].playlists.push(formatted);\n\n    if (typeof mainPlaylist === 'undefined' && role === 'main') {\n      mainPlaylist = playlist;\n      mainPlaylist.default = true;\n    }\n\n    return a;\n  }, {}); // if no playlists have role \"main\", mark the first as main\n\n  if (!mainPlaylist) {\n    var firstLabel = Object.keys(formattedPlaylists)[0];\n    formattedPlaylists[firstLabel].default = true;\n  }\n\n  return formattedPlaylists;\n};\nvar organizeVttPlaylists = function organizeVttPlaylists(playlists, sidxMapping) {\n  if (sidxMapping === void 0) {\n    sidxMapping = {};\n  }\n\n  return playlists.reduce(function (a, playlist) {\n    var label = playlist.attributes.lang || 'text';\n\n    if (!a[label]) {\n      a[label] = {\n        language: label,\n        default: false,\n        autoselect: false,\n        playlists: [],\n        uri: ''\n      };\n    }\n\n    a[label].playlists.push(addSidxSegmentsToPlaylist(formatVttPlaylist(playlist), sidxMapping));\n    return a;\n  }, {});\n};\n\nvar organizeCaptionServices = function organizeCaptionServices(captionServices) {\n  return captionServices.reduce(function (svcObj, svc) {\n    if (!svc) {\n      return svcObj;\n    }\n\n    svc.forEach(function (service) {\n      var channel = service.channel,\n          language = service.language;\n      svcObj[language] = {\n        autoselect: false,\n        default: false,\n        instreamId: channel,\n        language: language\n      };\n\n      if (service.hasOwnProperty('aspectRatio')) {\n        svcObj[language].aspectRatio = service.aspectRatio;\n      }\n\n      if (service.hasOwnProperty('easyReader')) {\n        svcObj[language].easyReader = service.easyReader;\n      }\n\n      if (service.hasOwnProperty('3D')) {\n        svcObj[language]['3D'] = service['3D'];\n      }\n    });\n    return svcObj;\n  }, {});\n};\n\nvar formatVideoPlaylist = function formatVideoPlaylist(_ref3) {\n  var _attributes2;\n\n  var attributes = _ref3.attributes,\n      segments = _ref3.segments,\n      sidx = _ref3.sidx,\n      discontinuityStarts = _ref3.discontinuityStarts;\n  var playlist = {\n    attributes: (_attributes2 = {\n      NAME: attributes.id,\n      AUDIO: 'audio',\n      SUBTITLES: 'subs',\n      RESOLUTION: {\n        width: attributes.width,\n        height: attributes.height\n      },\n      CODECS: attributes.codecs,\n      BANDWIDTH: attributes.bandwidth\n    }, _attributes2['PROGRAM-ID'] = 1, _attributes2),\n    uri: '',\n    endList: attributes.type === 'static',\n    timeline: attributes.periodStart,\n    resolvedUri: '',\n    targetDuration: attributes.duration,\n    discontinuityStarts: discontinuityStarts,\n    timelineStarts: attributes.timelineStarts,\n    segments: segments\n  };\n\n  if (attributes.contentProtection) {\n    playlist.contentProtection = attributes.contentProtection;\n  }\n\n  if (sidx) {\n    playlist.sidx = sidx;\n  }\n\n  return playlist;\n};\n\nvar videoOnly = function videoOnly(_ref4) {\n  var attributes = _ref4.attributes;\n  return attributes.mimeType === 'video/mp4' || attributes.mimeType === 'video/webm' || attributes.contentType === 'video';\n};\n\nvar audioOnly = function audioOnly(_ref5) {\n  var attributes = _ref5.attributes;\n  return attributes.mimeType === 'audio/mp4' || attributes.mimeType === 'audio/webm' || attributes.contentType === 'audio';\n};\n\nvar vttOnly = function vttOnly(_ref6) {\n  var attributes = _ref6.attributes;\n  return attributes.mimeType === 'text/vtt' || attributes.contentType === 'text';\n};\n/**\n * Contains start and timeline properties denoting a timeline start. For DASH, these will\n * be the same number.\n *\n * @typedef {Object} TimelineStart\n * @property {number} start - the start time of the timeline\n * @property {number} timeline - the timeline number\n */\n\n/**\n * Adds appropriate media and discontinuity sequence values to the segments and playlists.\n *\n * Throughout mpd-parser, the `number` attribute is used in relation to `startNumber`, a\n * DASH specific attribute used in constructing segment URI's from templates. However, from\n * an HLS perspective, the `number` attribute on a segment would be its `mediaSequence`\n * value, which should start at the original media sequence value (or 0) and increment by 1\n * for each segment thereafter. Since DASH's `startNumber` values are independent per\n * period, it doesn't make sense to use it for `number`. Instead, assume everything starts\n * from a 0 mediaSequence value and increment from there.\n *\n * Note that VHS currently doesn't use the `number` property, but it can be helpful for\n * debugging and making sense of the manifest.\n *\n * For live playlists, to account for values increasing in manifests when periods are\n * removed on refreshes, merging logic should be used to update the numbers to their\n * appropriate values (to ensure they're sequential and increasing).\n *\n * @param {Object[]} playlists - the playlists to update\n * @param {TimelineStart[]} timelineStarts - the timeline starts for the manifest\n */\n\n\nvar addMediaSequenceValues = function addMediaSequenceValues(playlists, timelineStarts) {\n  // increment all segments sequentially\n  playlists.forEach(function (playlist) {\n    playlist.mediaSequence = 0;\n    playlist.discontinuitySequence = findIndex(timelineStarts, function (_ref7) {\n      var timeline = _ref7.timeline;\n      return timeline === playlist.timeline;\n    });\n\n    if (!playlist.segments) {\n      return;\n    }\n\n    playlist.segments.forEach(function (segment, index) {\n      segment.number = index;\n    });\n  });\n};\n/**\n * Given a media group object, flattens all playlists within the media group into a single\n * array.\n *\n * @param {Object} mediaGroupObject - the media group object\n *\n * @return {Object[]}\n *         The media group playlists\n */\n\nvar flattenMediaGroupPlaylists = function flattenMediaGroupPlaylists(mediaGroupObject) {\n  if (!mediaGroupObject) {\n    return [];\n  }\n\n  return Object.keys(mediaGroupObject).reduce(function (acc, label) {\n    var labelContents = mediaGroupObject[label];\n    return acc.concat(labelContents.playlists);\n  }, []);\n};\nvar toM3u8 = function toM3u8(_ref8) {\n  var _mediaGroups;\n\n  var dashPlaylists = _ref8.dashPlaylists,\n      locations = _ref8.locations,\n      _ref8$sidxMapping = _ref8.sidxMapping,\n      sidxMapping = _ref8$sidxMapping === void 0 ? {} : _ref8$sidxMapping,\n      previousManifest = _ref8.previousManifest;\n\n  if (!dashPlaylists.length) {\n    return {};\n  } // grab all main manifest attributes\n\n\n  var _dashPlaylists$0$attr = dashPlaylists[0].attributes,\n      duration = _dashPlaylists$0$attr.sourceDuration,\n      type = _dashPlaylists$0$attr.type,\n      suggestedPresentationDelay = _dashPlaylists$0$attr.suggestedPresentationDelay,\n      minimumUpdatePeriod = _dashPlaylists$0$attr.minimumUpdatePeriod;\n  var videoPlaylists = mergeDiscontiguousPlaylists(dashPlaylists.filter(videoOnly)).map(formatVideoPlaylist);\n  var audioPlaylists = mergeDiscontiguousPlaylists(dashPlaylists.filter(audioOnly));\n  var vttPlaylists = mergeDiscontiguousPlaylists(dashPlaylists.filter(vttOnly));\n  var captions = dashPlaylists.map(function (playlist) {\n    return playlist.attributes.captionServices;\n  }).filter(Boolean);\n  var manifest = {\n    allowCache: true,\n    discontinuityStarts: [],\n    segments: [],\n    endList: true,\n    mediaGroups: (_mediaGroups = {\n      AUDIO: {},\n      VIDEO: {}\n    }, _mediaGroups['CLOSED-CAPTIONS'] = {}, _mediaGroups.SUBTITLES = {}, _mediaGroups),\n    uri: '',\n    duration: duration,\n    playlists: addSidxSegmentsToPlaylists(videoPlaylists, sidxMapping)\n  };\n\n  if (minimumUpdatePeriod >= 0) {\n    manifest.minimumUpdatePeriod = minimumUpdatePeriod * 1000;\n  }\n\n  if (locations) {\n    manifest.locations = locations;\n  }\n\n  if (type === 'dynamic') {\n    manifest.suggestedPresentationDelay = suggestedPresentationDelay;\n  }\n\n  var isAudioOnly = manifest.playlists.length === 0;\n  var organizedAudioGroup = audioPlaylists.length ? organizeAudioPlaylists(audioPlaylists, sidxMapping, isAudioOnly) : null;\n  var organizedVttGroup = vttPlaylists.length ? organizeVttPlaylists(vttPlaylists, sidxMapping) : null;\n  var formattedPlaylists = videoPlaylists.concat(flattenMediaGroupPlaylists(organizedAudioGroup), flattenMediaGroupPlaylists(organizedVttGroup));\n  var playlistTimelineStarts = formattedPlaylists.map(function (_ref9) {\n    var timelineStarts = _ref9.timelineStarts;\n    return timelineStarts;\n  });\n  manifest.timelineStarts = getUniqueTimelineStarts(playlistTimelineStarts);\n  addMediaSequenceValues(formattedPlaylists, manifest.timelineStarts);\n\n  if (organizedAudioGroup) {\n    manifest.mediaGroups.AUDIO.audio = organizedAudioGroup;\n  }\n\n  if (organizedVttGroup) {\n    manifest.mediaGroups.SUBTITLES.subs = organizedVttGroup;\n  }\n\n  if (captions.length) {\n    manifest.mediaGroups['CLOSED-CAPTIONS'].cc = organizeCaptionServices(captions);\n  }\n\n  if (previousManifest) {\n    return positionManifestOnTimeline({\n      oldManifest: previousManifest,\n      newManifest: manifest\n    });\n  }\n\n  return manifest;\n};\n\n/**\n * Calculates the R (repetition) value for a live stream (for the final segment\n * in a manifest where the r value is negative 1)\n *\n * @param {Object} attributes\n *        Object containing all inherited attributes from parent elements with attribute\n *        names as keys\n * @param {number} time\n *        current time (typically the total time up until the final segment)\n * @param {number} duration\n *        duration property for the given <S />\n *\n * @return {number}\n *        R value to reach the end of the given period\n */\nvar getLiveRValue = function getLiveRValue(attributes, time, duration) {\n  var NOW = attributes.NOW,\n      clientOffset = attributes.clientOffset,\n      availabilityStartTime = attributes.availabilityStartTime,\n      _attributes$timescale = attributes.timescale,\n      timescale = _attributes$timescale === void 0 ? 1 : _attributes$timescale,\n      _attributes$periodSta = attributes.periodStart,\n      periodStart = _attributes$periodSta === void 0 ? 0 : _attributes$periodSta,\n      _attributes$minimumUp = attributes.minimumUpdatePeriod,\n      minimumUpdatePeriod = _attributes$minimumUp === void 0 ? 0 : _attributes$minimumUp;\n  var now = (NOW + clientOffset) / 1000;\n  var periodStartWC = availabilityStartTime + periodStart;\n  var periodEndWC = now + minimumUpdatePeriod;\n  var periodDuration = periodEndWC - periodStartWC;\n  return Math.ceil((periodDuration * timescale - time) / duration);\n};\n/**\n * Uses information provided by SegmentTemplate.SegmentTimeline to determine segment\n * timing and duration\n *\n * @param {Object} attributes\n *        Object containing all inherited attributes from parent elements with attribute\n *        names as keys\n * @param {Object[]} segmentTimeline\n *        List of objects representing the attributes of each S element contained within\n *\n * @return {{number: number, duration: number, time: number, timeline: number}[]}\n *         List of Objects with segment timing and duration info\n */\n\n\nvar parseByTimeline = function parseByTimeline(attributes, segmentTimeline) {\n  var type = attributes.type,\n      _attributes$minimumUp2 = attributes.minimumUpdatePeriod,\n      minimumUpdatePeriod = _attributes$minimumUp2 === void 0 ? 0 : _attributes$minimumUp2,\n      _attributes$media = attributes.media,\n      media = _attributes$media === void 0 ? '' : _attributes$media,\n      sourceDuration = attributes.sourceDuration,\n      _attributes$timescale2 = attributes.timescale,\n      timescale = _attributes$timescale2 === void 0 ? 1 : _attributes$timescale2,\n      _attributes$startNumb = attributes.startNumber,\n      startNumber = _attributes$startNumb === void 0 ? 1 : _attributes$startNumb,\n      timeline = attributes.periodStart;\n  var segments = [];\n  var time = -1;\n\n  for (var sIndex = 0; sIndex < segmentTimeline.length; sIndex++) {\n    var S = segmentTimeline[sIndex];\n    var duration = S.d;\n    var repeat = S.r || 0;\n    var segmentTime = S.t || 0;\n\n    if (time < 0) {\n      // first segment\n      time = segmentTime;\n    }\n\n    if (segmentTime && segmentTime > time) {\n      // discontinuity\n      // TODO: How to handle this type of discontinuity\n      // timeline++ here would treat it like HLS discontuity and content would\n      // get appended without gap\n      // E.G.\n      //  <S t=\"0\" d=\"1\" />\n      //  <S d=\"1\" />\n      //  <S d=\"1\" />\n      //  <S t=\"5\" d=\"1\" />\n      // would have $Time$ values of [0, 1, 2, 5]\n      // should this be appened at time positions [0, 1, 2, 3],(#EXT-X-DISCONTINUITY)\n      // or [0, 1, 2, gap, gap, 5]? (#EXT-X-GAP)\n      // does the value of sourceDuration consider this when calculating arbitrary\n      // negative @r repeat value?\n      // E.G. Same elements as above with this added at the end\n      //  <S d=\"1\" r=\"-1\" />\n      //  with a sourceDuration of 10\n      // Would the 2 gaps be included in the time duration calculations resulting in\n      // 8 segments with $Time$ values of [0, 1, 2, 5, 6, 7, 8, 9] or 10 segments\n      // with $Time$ values of [0, 1, 2, 5, 6, 7, 8, 9, 10, 11] ?\n      time = segmentTime;\n    }\n\n    var count = void 0;\n\n    if (repeat < 0) {\n      var nextS = sIndex + 1;\n\n      if (nextS === segmentTimeline.length) {\n        // last segment\n        if (type === 'dynamic' && minimumUpdatePeriod > 0 && media.indexOf('$Number$') > 0) {\n          count = getLiveRValue(attributes, time, duration);\n        } else {\n          // TODO: This may be incorrect depending on conclusion of TODO above\n          count = (sourceDuration * timescale - time) / duration;\n        }\n      } else {\n        count = (segmentTimeline[nextS].t - time) / duration;\n      }\n    } else {\n      count = repeat + 1;\n    }\n\n    var end = startNumber + segments.length + count;\n    var number = startNumber + segments.length;\n\n    while (number < end) {\n      segments.push({\n        number: number,\n        duration: duration / timescale,\n        time: time,\n        timeline: timeline\n      });\n      time += duration;\n      number++;\n    }\n  }\n\n  return segments;\n};\n\nvar identifierPattern = /\\$([A-z]*)(?:(%0)([0-9]+)d)?\\$/g;\n/**\n * Replaces template identifiers with corresponding values. To be used as the callback\n * for String.prototype.replace\n *\n * @name replaceCallback\n * @function\n * @param {string} match\n *        Entire match of identifier\n * @param {string} identifier\n *        Name of matched identifier\n * @param {string} format\n *        Format tag string. Its presence indicates that padding is expected\n * @param {string} width\n *        Desired length of the replaced value. Values less than this width shall be left\n *        zero padded\n * @return {string}\n *         Replacement for the matched identifier\n */\n\n/**\n * Returns a function to be used as a callback for String.prototype.replace to replace\n * template identifiers\n *\n * @param {Obect} values\n *        Object containing values that shall be used to replace known identifiers\n * @param {number} values.RepresentationID\n *        Value of the Representation@id attribute\n * @param {number} values.Number\n *        Number of the corresponding segment\n * @param {number} values.Bandwidth\n *        Value of the Representation@bandwidth attribute.\n * @param {number} values.Time\n *        Timestamp value of the corresponding segment\n * @return {replaceCallback}\n *         Callback to be used with String.prototype.replace to replace identifiers\n */\n\nvar identifierReplacement = function identifierReplacement(values) {\n  return function (match, identifier, format, width) {\n    if (match === '$$') {\n      // escape sequence\n      return '$';\n    }\n\n    if (typeof values[identifier] === 'undefined') {\n      return match;\n    }\n\n    var value = '' + values[identifier];\n\n    if (identifier === 'RepresentationID') {\n      // Format tag shall not be present with RepresentationID\n      return value;\n    }\n\n    if (!format) {\n      width = 1;\n    } else {\n      width = parseInt(width, 10);\n    }\n\n    if (value.length >= width) {\n      return value;\n    }\n\n    return \"\" + new Array(width - value.length + 1).join('0') + value;\n  };\n};\n/**\n * Constructs a segment url from a template string\n *\n * @param {string} url\n *        Template string to construct url from\n * @param {Obect} values\n *        Object containing values that shall be used to replace known identifiers\n * @param {number} values.RepresentationID\n *        Value of the Representation@id attribute\n * @param {number} values.Number\n *        Number of the corresponding segment\n * @param {number} values.Bandwidth\n *        Value of the Representation@bandwidth attribute.\n * @param {number} values.Time\n *        Timestamp value of the corresponding segment\n * @return {string}\n *         Segment url with identifiers replaced\n */\n\nvar constructTemplateUrl = function constructTemplateUrl(url, values) {\n  return url.replace(identifierPattern, identifierReplacement(values));\n};\n/**\n * Generates a list of objects containing timing and duration information about each\n * segment needed to generate segment uris and the complete segment object\n *\n * @param {Object} attributes\n *        Object containing all inherited attributes from parent elements with attribute\n *        names as keys\n * @param {Object[]|undefined} segmentTimeline\n *        List of objects representing the attributes of each S element contained within\n *        the SegmentTimeline element\n * @return {{number: number, duration: number, time: number, timeline: number}[]}\n *         List of Objects with segment timing and duration info\n */\n\nvar parseTemplateInfo = function parseTemplateInfo(attributes, segmentTimeline) {\n  if (!attributes.duration && !segmentTimeline) {\n    // if neither @duration or SegmentTimeline are present, then there shall be exactly\n    // one media segment\n    return [{\n      number: attributes.startNumber || 1,\n      duration: attributes.sourceDuration,\n      time: 0,\n      timeline: attributes.periodStart\n    }];\n  }\n\n  if (attributes.duration) {\n    return parseByDuration(attributes);\n  }\n\n  return parseByTimeline(attributes, segmentTimeline);\n};\n/**\n * Generates a list of segments using information provided by the SegmentTemplate element\n *\n * @param {Object} attributes\n *        Object containing all inherited attributes from parent elements with attribute\n *        names as keys\n * @param {Object[]|undefined} segmentTimeline\n *        List of objects representing the attributes of each S element contained within\n *        the SegmentTimeline element\n * @return {Object[]}\n *         List of segment objects\n */\n\nvar segmentsFromTemplate = function segmentsFromTemplate(attributes, segmentTimeline) {\n  var templateValues = {\n    RepresentationID: attributes.id,\n    Bandwidth: attributes.bandwidth || 0\n  };\n  var _attributes$initializ = attributes.initialization,\n      initialization = _attributes$initializ === void 0 ? {\n    sourceURL: '',\n    range: ''\n  } : _attributes$initializ;\n  var mapSegment = urlTypeToSegment({\n    baseUrl: attributes.baseUrl,\n    source: constructTemplateUrl(initialization.sourceURL, templateValues),\n    range: initialization.range\n  });\n  var segments = parseTemplateInfo(attributes, segmentTimeline);\n  return segments.map(function (segment) {\n    templateValues.Number = segment.number;\n    templateValues.Time = segment.time;\n    var uri = constructTemplateUrl(attributes.media || '', templateValues); // See DASH spec section 5.3.9.2.2\n    // - if timescale isn't present on any level, default to 1.\n\n    var timescale = attributes.timescale || 1; // - if presentationTimeOffset isn't present on any level, default to 0\n\n    var presentationTimeOffset = attributes.presentationTimeOffset || 0;\n    var presentationTime = // Even if the @t attribute is not specified for the segment, segment.time is\n    // calculated in mpd-parser prior to this, so it's assumed to be available.\n    attributes.periodStart + (segment.time - presentationTimeOffset) / timescale;\n    var map = {\n      uri: uri,\n      timeline: segment.timeline,\n      duration: segment.duration,\n      resolvedUri: resolveUrl(attributes.baseUrl || '', uri),\n      map: mapSegment,\n      number: segment.number,\n      presentationTime: presentationTime\n    };\n    return map;\n  });\n};\n\n/**\n * Converts a <SegmentUrl> (of type URLType from the DASH spec 5.3.9.2 Table 14)\n * to an object that matches the output of a segment in videojs/mpd-parser\n *\n * @param {Object} attributes\n *   Object containing all inherited attributes from parent elements with attribute\n *   names as keys\n * @param {Object} segmentUrl\n *   <SegmentURL> node to translate into a segment object\n * @return {Object} translated segment object\n */\n\nvar SegmentURLToSegmentObject = function SegmentURLToSegmentObject(attributes, segmentUrl) {\n  var baseUrl = attributes.baseUrl,\n      _attributes$initializ = attributes.initialization,\n      initialization = _attributes$initializ === void 0 ? {} : _attributes$initializ;\n  var initSegment = urlTypeToSegment({\n    baseUrl: baseUrl,\n    source: initialization.sourceURL,\n    range: initialization.range\n  });\n  var segment = urlTypeToSegment({\n    baseUrl: baseUrl,\n    source: segmentUrl.media,\n    range: segmentUrl.mediaRange\n  });\n  segment.map = initSegment;\n  return segment;\n};\n/**\n * Generates a list of segments using information provided by the SegmentList element\n * SegmentList (DASH SPEC Section 5.3.9.3.2) contains a set of <SegmentURL> nodes.  Each\n * node should be translated into segment.\n *\n * @param {Object} attributes\n *   Object containing all inherited attributes from parent elements with attribute\n *   names as keys\n * @param {Object[]|undefined} segmentTimeline\n *        List of objects representing the attributes of each S element contained within\n *        the SegmentTimeline element\n * @return {Object.<Array>} list of segments\n */\n\n\nvar segmentsFromList = function segmentsFromList(attributes, segmentTimeline) {\n  var duration = attributes.duration,\n      _attributes$segmentUr = attributes.segmentUrls,\n      segmentUrls = _attributes$segmentUr === void 0 ? [] : _attributes$segmentUr,\n      periodStart = attributes.periodStart; // Per spec (5.3.9.2.1) no way to determine segment duration OR\n  // if both SegmentTimeline and @duration are defined, it is outside of spec.\n\n  if (!duration && !segmentTimeline || duration && segmentTimeline) {\n    throw new Error(errors.SEGMENT_TIME_UNSPECIFIED);\n  }\n\n  var segmentUrlMap = segmentUrls.map(function (segmentUrlObject) {\n    return SegmentURLToSegmentObject(attributes, segmentUrlObject);\n  });\n  var segmentTimeInfo;\n\n  if (duration) {\n    segmentTimeInfo = parseByDuration(attributes);\n  }\n\n  if (segmentTimeline) {\n    segmentTimeInfo = parseByTimeline(attributes, segmentTimeline);\n  }\n\n  var segments = segmentTimeInfo.map(function (segmentTime, index) {\n    if (segmentUrlMap[index]) {\n      var segment = segmentUrlMap[index]; // See DASH spec section 5.3.9.2.2\n      // - if timescale isn't present on any level, default to 1.\n\n      var timescale = attributes.timescale || 1; // - if presentationTimeOffset isn't present on any level, default to 0\n\n      var presentationTimeOffset = attributes.presentationTimeOffset || 0;\n      segment.timeline = segmentTime.timeline;\n      segment.duration = segmentTime.duration;\n      segment.number = segmentTime.number;\n      segment.presentationTime = periodStart + (segmentTime.time - presentationTimeOffset) / timescale;\n      return segment;\n    } // Since we're mapping we should get rid of any blank segments (in case\n    // the given SegmentTimeline is handling for more elements than we have\n    // SegmentURLs for).\n\n  }).filter(function (segment) {\n    return segment;\n  });\n  return segments;\n};\n\nvar generateSegments = function generateSegments(_ref) {\n  var attributes = _ref.attributes,\n      segmentInfo = _ref.segmentInfo;\n  var segmentAttributes;\n  var segmentsFn;\n\n  if (segmentInfo.template) {\n    segmentsFn = segmentsFromTemplate;\n    segmentAttributes = merge(attributes, segmentInfo.template);\n  } else if (segmentInfo.base) {\n    segmentsFn = segmentsFromBase;\n    segmentAttributes = merge(attributes, segmentInfo.base);\n  } else if (segmentInfo.list) {\n    segmentsFn = segmentsFromList;\n    segmentAttributes = merge(attributes, segmentInfo.list);\n  }\n\n  var segmentsInfo = {\n    attributes: attributes\n  };\n\n  if (!segmentsFn) {\n    return segmentsInfo;\n  }\n\n  var segments = segmentsFn(segmentAttributes, segmentInfo.segmentTimeline); // The @duration attribute will be used to determin the playlist's targetDuration which\n  // must be in seconds. Since we've generated the segment list, we no longer need\n  // @duration to be in @timescale units, so we can convert it here.\n\n  if (segmentAttributes.duration) {\n    var _segmentAttributes = segmentAttributes,\n        duration = _segmentAttributes.duration,\n        _segmentAttributes$ti = _segmentAttributes.timescale,\n        timescale = _segmentAttributes$ti === void 0 ? 1 : _segmentAttributes$ti;\n    segmentAttributes.duration = duration / timescale;\n  } else if (segments.length) {\n    // if there is no @duration attribute, use the largest segment duration as\n    // as target duration\n    segmentAttributes.duration = segments.reduce(function (max, segment) {\n      return Math.max(max, Math.ceil(segment.duration));\n    }, 0);\n  } else {\n    segmentAttributes.duration = 0;\n  }\n\n  segmentsInfo.attributes = segmentAttributes;\n  segmentsInfo.segments = segments; // This is a sidx box without actual segment information\n\n  if (segmentInfo.base && segmentAttributes.indexRange) {\n    segmentsInfo.sidx = segments[0];\n    segmentsInfo.segments = [];\n  }\n\n  return segmentsInfo;\n};\nvar toPlaylists = function toPlaylists(representations) {\n  return representations.map(generateSegments);\n};\n\nvar findChildren = function findChildren(element, name) {\n  return from(element.childNodes).filter(function (_ref) {\n    var tagName = _ref.tagName;\n    return tagName === name;\n  });\n};\nvar getContent = function getContent(element) {\n  return element.textContent.trim();\n};\n\nvar parseDuration = function parseDuration(str) {\n  var SECONDS_IN_YEAR = 365 * 24 * 60 * 60;\n  var SECONDS_IN_MONTH = 30 * 24 * 60 * 60;\n  var SECONDS_IN_DAY = 24 * 60 * 60;\n  var SECONDS_IN_HOUR = 60 * 60;\n  var SECONDS_IN_MIN = 60; // P10Y10M10DT10H10M10.1S\n\n  var durationRegex = /P(?:(\\d*)Y)?(?:(\\d*)M)?(?:(\\d*)D)?(?:T(?:(\\d*)H)?(?:(\\d*)M)?(?:([\\d.]*)S)?)?/;\n  var match = durationRegex.exec(str);\n\n  if (!match) {\n    return 0;\n  }\n\n  var _match$slice = match.slice(1),\n      year = _match$slice[0],\n      month = _match$slice[1],\n      day = _match$slice[2],\n      hour = _match$slice[3],\n      minute = _match$slice[4],\n      second = _match$slice[5];\n\n  return parseFloat(year || 0) * SECONDS_IN_YEAR + parseFloat(month || 0) * SECONDS_IN_MONTH + parseFloat(day || 0) * SECONDS_IN_DAY + parseFloat(hour || 0) * SECONDS_IN_HOUR + parseFloat(minute || 0) * SECONDS_IN_MIN + parseFloat(second || 0);\n};\nvar parseDate = function parseDate(str) {\n  // Date format without timezone according to ISO 8601\n  // YYY-MM-DDThh:mm:ss.ssssss\n  var dateRegex = /^\\d+-\\d+-\\d+T\\d+:\\d+:\\d+(\\.\\d+)?$/; // If the date string does not specifiy a timezone, we must specifiy UTC. This is\n  // expressed by ending with 'Z'\n\n  if (dateRegex.test(str)) {\n    str += 'Z';\n  }\n\n  return Date.parse(str);\n};\n\nvar parsers = {\n  /**\n   * Specifies the duration of the entire Media Presentation. Format is a duration string\n   * as specified in ISO 8601\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The duration in seconds\n   */\n  mediaPresentationDuration: function mediaPresentationDuration(value) {\n    return parseDuration(value);\n  },\n\n  /**\n   * Specifies the Segment availability start time for all Segments referred to in this\n   * MPD. For a dynamic manifest, it specifies the anchor for the earliest availability\n   * time. Format is a date string as specified in ISO 8601\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The date as seconds from unix epoch\n   */\n  availabilityStartTime: function availabilityStartTime(value) {\n    return parseDate(value) / 1000;\n  },\n\n  /**\n   * Specifies the smallest period between potential changes to the MPD. Format is a\n   * duration string as specified in ISO 8601\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The duration in seconds\n   */\n  minimumUpdatePeriod: function minimumUpdatePeriod(value) {\n    return parseDuration(value);\n  },\n\n  /**\n   * Specifies the suggested presentation delay. Format is a\n   * duration string as specified in ISO 8601\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The duration in seconds\n   */\n  suggestedPresentationDelay: function suggestedPresentationDelay(value) {\n    return parseDuration(value);\n  },\n\n  /**\n   * specifices the type of mpd. Can be either \"static\" or \"dynamic\"\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   *\n   * @return {string}\n   *         The type as a string\n   */\n  type: function type(value) {\n    return value;\n  },\n\n  /**\n   * Specifies the duration of the smallest time shifting buffer for any Representation\n   * in the MPD. Format is a duration string as specified in ISO 8601\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The duration in seconds\n   */\n  timeShiftBufferDepth: function timeShiftBufferDepth(value) {\n    return parseDuration(value);\n  },\n\n  /**\n   * Specifies the PeriodStart time of the Period relative to the availabilityStarttime.\n   * Format is a duration string as specified in ISO 8601\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The duration in seconds\n   */\n  start: function start(value) {\n    return parseDuration(value);\n  },\n\n  /**\n   * Specifies the width of the visual presentation\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The parsed width\n   */\n  width: function width(value) {\n    return parseInt(value, 10);\n  },\n\n  /**\n   * Specifies the height of the visual presentation\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The parsed height\n   */\n  height: function height(value) {\n    return parseInt(value, 10);\n  },\n\n  /**\n   * Specifies the bitrate of the representation\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The parsed bandwidth\n   */\n  bandwidth: function bandwidth(value) {\n    return parseInt(value, 10);\n  },\n\n  /**\n   * Specifies the number of the first Media Segment in this Representation in the Period\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The parsed number\n   */\n  startNumber: function startNumber(value) {\n    return parseInt(value, 10);\n  },\n\n  /**\n   * Specifies the timescale in units per seconds\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The parsed timescale\n   */\n  timescale: function timescale(value) {\n    return parseInt(value, 10);\n  },\n\n  /**\n   * Specifies the presentationTimeOffset.\n   *\n   * @param {string} value\n   *        value of the attribute as a string\n   *\n   * @return {number}\n   *         The parsed presentationTimeOffset\n   */\n  presentationTimeOffset: function presentationTimeOffset(value) {\n    return parseInt(value, 10);\n  },\n\n  /**\n   * Specifies the constant approximate Segment duration\n   * NOTE: The <Period> element also contains an @duration attribute. This duration\n   *       specifies the duration of the Period. This attribute is currently not\n   *       supported by the rest of the parser, however we still check for it to prevent\n   *       errors.\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The parsed duration\n   */\n  duration: function duration(value) {\n    var parsedValue = parseInt(value, 10);\n\n    if (isNaN(parsedValue)) {\n      return parseDuration(value);\n    }\n\n    return parsedValue;\n  },\n\n  /**\n   * Specifies the Segment duration, in units of the value of the @timescale.\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The parsed duration\n   */\n  d: function d(value) {\n    return parseInt(value, 10);\n  },\n\n  /**\n   * Specifies the MPD start time, in @timescale units, the first Segment in the series\n   * starts relative to the beginning of the Period\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The parsed time\n   */\n  t: function t(value) {\n    return parseInt(value, 10);\n  },\n\n  /**\n   * Specifies the repeat count of the number of following contiguous Segments with the\n   * same duration expressed by the value of @d\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The parsed number\n   */\n  r: function r(value) {\n    return parseInt(value, 10);\n  },\n\n  /**\n   * Default parser for all other attributes. Acts as a no-op and just returns the value\n   * as a string\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {string}\n   *         Unparsed value\n   */\n  DEFAULT: function DEFAULT(value) {\n    return value;\n  }\n};\n/**\n * Gets all the attributes and values of the provided node, parses attributes with known\n * types, and returns an object with attribute names mapped to values.\n *\n * @param {Node} el\n *        The node to parse attributes from\n * @return {Object}\n *         Object with all attributes of el parsed\n */\n\nvar parseAttributes = function parseAttributes(el) {\n  if (!(el && el.attributes)) {\n    return {};\n  }\n\n  return from(el.attributes).reduce(function (a, e) {\n    var parseFn = parsers[e.name] || parsers.DEFAULT;\n    a[e.name] = parseFn(e.value);\n    return a;\n  }, {});\n};\n\nvar keySystemsMap = {\n  'urn:uuid:1077efec-c0b2-4d02-ace3-3c1e52e2fb4b': 'org.w3.clearkey',\n  'urn:uuid:edef8ba9-79d6-4ace-a3c8-27dcd51d21ed': 'com.widevine.alpha',\n  'urn:uuid:9a04f079-9840-4286-ab92-e65be0885f95': 'com.microsoft.playready',\n  'urn:uuid:f239e769-efa3-4850-9c16-a903c6932efb': 'com.adobe.primetime'\n};\n/**\n * Builds a list of urls that is the product of the reference urls and BaseURL values\n *\n * @param {string[]} referenceUrls\n *        List of reference urls to resolve to\n * @param {Node[]} baseUrlElements\n *        List of BaseURL nodes from the mpd\n * @return {string[]}\n *         List of resolved urls\n */\n\nvar buildBaseUrls = function buildBaseUrls(referenceUrls, baseUrlElements) {\n  if (!baseUrlElements.length) {\n    return referenceUrls;\n  }\n\n  return flatten(referenceUrls.map(function (reference) {\n    return baseUrlElements.map(function (baseUrlElement) {\n      return resolveUrl(reference, getContent(baseUrlElement));\n    });\n  }));\n};\n/**\n * Contains all Segment information for its containing AdaptationSet\n *\n * @typedef {Object} SegmentInformation\n * @property {Object|undefined} template\n *           Contains the attributes for the SegmentTemplate node\n * @property {Object[]|undefined} segmentTimeline\n *           Contains a list of atrributes for each S node within the SegmentTimeline node\n * @property {Object|undefined} list\n *           Contains the attributes for the SegmentList node\n * @property {Object|undefined} base\n *           Contains the attributes for the SegmentBase node\n */\n\n/**\n * Returns all available Segment information contained within the AdaptationSet node\n *\n * @param {Node} adaptationSet\n *        The AdaptationSet node to get Segment information from\n * @return {SegmentInformation}\n *         The Segment information contained within the provided AdaptationSet\n */\n\nvar getSegmentInformation = function getSegmentInformation(adaptationSet) {\n  var segmentTemplate = findChildren(adaptationSet, 'SegmentTemplate')[0];\n  var segmentList = findChildren(adaptationSet, 'SegmentList')[0];\n  var segmentUrls = segmentList && findChildren(segmentList, 'SegmentURL').map(function (s) {\n    return merge({\n      tag: 'SegmentURL'\n    }, parseAttributes(s));\n  });\n  var segmentBase = findChildren(adaptationSet, 'SegmentBase')[0];\n  var segmentTimelineParentNode = segmentList || segmentTemplate;\n  var segmentTimeline = segmentTimelineParentNode && findChildren(segmentTimelineParentNode, 'SegmentTimeline')[0];\n  var segmentInitializationParentNode = segmentList || segmentBase || segmentTemplate;\n  var segmentInitialization = segmentInitializationParentNode && findChildren(segmentInitializationParentNode, 'Initialization')[0]; // SegmentTemplate is handled slightly differently, since it can have both\n  // @initialization and an <Initialization> node.  @initialization can be templated,\n  // while the node can have a url and range specified.  If the <SegmentTemplate> has\n  // both @initialization and an <Initialization> subelement we opt to override with\n  // the node, as this interaction is not defined in the spec.\n\n  var template = segmentTemplate && parseAttributes(segmentTemplate);\n\n  if (template && segmentInitialization) {\n    template.initialization = segmentInitialization && parseAttributes(segmentInitialization);\n  } else if (template && template.initialization) {\n    // If it is @initialization we convert it to an object since this is the format that\n    // later functions will rely on for the initialization segment.  This is only valid\n    // for <SegmentTemplate>\n    template.initialization = {\n      sourceURL: template.initialization\n    };\n  }\n\n  var segmentInfo = {\n    template: template,\n    segmentTimeline: segmentTimeline && findChildren(segmentTimeline, 'S').map(function (s) {\n      return parseAttributes(s);\n    }),\n    list: segmentList && merge(parseAttributes(segmentList), {\n      segmentUrls: segmentUrls,\n      initialization: parseAttributes(segmentInitialization)\n    }),\n    base: segmentBase && merge(parseAttributes(segmentBase), {\n      initialization: parseAttributes(segmentInitialization)\n    })\n  };\n  Object.keys(segmentInfo).forEach(function (key) {\n    if (!segmentInfo[key]) {\n      delete segmentInfo[key];\n    }\n  });\n  return segmentInfo;\n};\n/**\n * Contains Segment information and attributes needed to construct a Playlist object\n * from a Representation\n *\n * @typedef {Object} RepresentationInformation\n * @property {SegmentInformation} segmentInfo\n *           Segment information for this Representation\n * @property {Object} attributes\n *           Inherited attributes for this Representation\n */\n\n/**\n * Maps a Representation node to an object containing Segment information and attributes\n *\n * @name inheritBaseUrlsCallback\n * @function\n * @param {Node} representation\n *        Representation node from the mpd\n * @return {RepresentationInformation}\n *         Representation information needed to construct a Playlist object\n */\n\n/**\n * Returns a callback for Array.prototype.map for mapping Representation nodes to\n * Segment information and attributes using inherited BaseURL nodes.\n *\n * @param {Object} adaptationSetAttributes\n *        Contains attributes inherited by the AdaptationSet\n * @param {string[]} adaptationSetBaseUrls\n *        Contains list of resolved base urls inherited by the AdaptationSet\n * @param {SegmentInformation} adaptationSetSegmentInfo\n *        Contains Segment information for the AdaptationSet\n * @return {inheritBaseUrlsCallback}\n *         Callback map function\n */\n\nvar inheritBaseUrls = function inheritBaseUrls(adaptationSetAttributes, adaptationSetBaseUrls, adaptationSetSegmentInfo) {\n  return function (representation) {\n    var repBaseUrlElements = findChildren(representation, 'BaseURL');\n    var repBaseUrls = buildBaseUrls(adaptationSetBaseUrls, repBaseUrlElements);\n    var attributes = merge(adaptationSetAttributes, parseAttributes(representation));\n    var representationSegmentInfo = getSegmentInformation(representation);\n    return repBaseUrls.map(function (baseUrl) {\n      return {\n        segmentInfo: merge(adaptationSetSegmentInfo, representationSegmentInfo),\n        attributes: merge(attributes, {\n          baseUrl: baseUrl\n        })\n      };\n    });\n  };\n};\n/**\n * Tranforms a series of content protection nodes to\n * an object containing pssh data by key system\n *\n * @param {Node[]} contentProtectionNodes\n *        Content protection nodes\n * @return {Object}\n *        Object containing pssh data by key system\n */\n\nvar generateKeySystemInformation = function generateKeySystemInformation(contentProtectionNodes) {\n  return contentProtectionNodes.reduce(function (acc, node) {\n    var attributes = parseAttributes(node); // Although it could be argued that according to the UUID RFC spec the UUID string (a-f chars) should be generated\n    // as a lowercase string it also mentions it should be treated as case-insensitive on input. Since the key system\n    // UUIDs in the keySystemsMap are hardcoded as lowercase in the codebase there isn't any reason not to do\n    // .toLowerCase() on the input UUID string from the manifest (at least I could not think of one).\n\n    if (attributes.schemeIdUri) {\n      attributes.schemeIdUri = attributes.schemeIdUri.toLowerCase();\n    }\n\n    var keySystem = keySystemsMap[attributes.schemeIdUri];\n\n    if (keySystem) {\n      acc[keySystem] = {\n        attributes: attributes\n      };\n      var psshNode = findChildren(node, 'cenc:pssh')[0];\n\n      if (psshNode) {\n        var pssh = getContent(psshNode);\n        acc[keySystem].pssh = pssh && decodeB64ToUint8Array(pssh);\n      }\n    }\n\n    return acc;\n  }, {});\n}; // defined in ANSI_SCTE 214-1 2016\n\n\nvar parseCaptionServiceMetadata = function parseCaptionServiceMetadata(service) {\n  // 608 captions\n  if (service.schemeIdUri === 'urn:scte:dash:cc:cea-608:2015') {\n    var values = typeof service.value !== 'string' ? [] : service.value.split(';');\n    return values.map(function (value) {\n      var channel;\n      var language; // default language to value\n\n      language = value;\n\n      if (/^CC\\d=/.test(value)) {\n        var _value$split = value.split('=');\n\n        channel = _value$split[0];\n        language = _value$split[1];\n      } else if (/^CC\\d$/.test(value)) {\n        channel = value;\n      }\n\n      return {\n        channel: channel,\n        language: language\n      };\n    });\n  } else if (service.schemeIdUri === 'urn:scte:dash:cc:cea-708:2015') {\n    var _values = typeof service.value !== 'string' ? [] : service.value.split(';');\n\n    return _values.map(function (value) {\n      var flags = {\n        // service or channel number 1-63\n        'channel': undefined,\n        // language is a 3ALPHA per ISO 639.2/B\n        // field is required\n        'language': undefined,\n        // BIT 1/0 or ?\n        // default value is 1, meaning 16:9 aspect ratio, 0 is 4:3, ? is unknown\n        'aspectRatio': 1,\n        // BIT 1/0\n        // easy reader flag indicated the text is tailed to the needs of beginning readers\n        // default 0, or off\n        'easyReader': 0,\n        // BIT 1/0\n        // If 3d metadata is present (CEA-708.1) then 1\n        // default 0\n        '3D': 0\n      };\n\n      if (/=/.test(value)) {\n        var _value$split2 = value.split('='),\n            channel = _value$split2[0],\n            _value$split2$ = _value$split2[1],\n            opts = _value$split2$ === void 0 ? '' : _value$split2$;\n\n        flags.channel = channel;\n        flags.language = value;\n        opts.split(',').forEach(function (opt) {\n          var _opt$split = opt.split(':'),\n              name = _opt$split[0],\n              val = _opt$split[1];\n\n          if (name === 'lang') {\n            flags.language = val; // er for easyReadery\n          } else if (name === 'er') {\n            flags.easyReader = Number(val); // war for wide aspect ratio\n          } else if (name === 'war') {\n            flags.aspectRatio = Number(val);\n          } else if (name === '3D') {\n            flags['3D'] = Number(val);\n          }\n        });\n      } else {\n        flags.language = value;\n      }\n\n      if (flags.channel) {\n        flags.channel = 'SERVICE' + flags.channel;\n      }\n\n      return flags;\n    });\n  }\n};\n/**\n * Maps an AdaptationSet node to a list of Representation information objects\n *\n * @name toRepresentationsCallback\n * @function\n * @param {Node} adaptationSet\n *        AdaptationSet node from the mpd\n * @return {RepresentationInformation[]}\n *         List of objects containing Representaion information\n */\n\n/**\n * Returns a callback for Array.prototype.map for mapping AdaptationSet nodes to a list of\n * Representation information objects\n *\n * @param {Object} periodAttributes\n *        Contains attributes inherited by the Period\n * @param {string[]} periodBaseUrls\n *        Contains list of resolved base urls inherited by the Period\n * @param {string[]} periodSegmentInfo\n *        Contains Segment Information at the period level\n * @return {toRepresentationsCallback}\n *         Callback map function\n */\n\nvar toRepresentations = function toRepresentations(periodAttributes, periodBaseUrls, periodSegmentInfo) {\n  return function (adaptationSet) {\n    var adaptationSetAttributes = parseAttributes(adaptationSet);\n    var adaptationSetBaseUrls = buildBaseUrls(periodBaseUrls, findChildren(adaptationSet, 'BaseURL'));\n    var role = findChildren(adaptationSet, 'Role')[0];\n    var roleAttributes = {\n      role: parseAttributes(role)\n    };\n    var attrs = merge(periodAttributes, adaptationSetAttributes, roleAttributes);\n    var accessibility = findChildren(adaptationSet, 'Accessibility')[0];\n    var captionServices = parseCaptionServiceMetadata(parseAttributes(accessibility));\n\n    if (captionServices) {\n      attrs = merge(attrs, {\n        captionServices: captionServices\n      });\n    }\n\n    var label = findChildren(adaptationSet, 'Label')[0];\n\n    if (label && label.childNodes.length) {\n      var labelVal = label.childNodes[0].nodeValue.trim();\n      attrs = merge(attrs, {\n        label: labelVal\n      });\n    }\n\n    var contentProtection = generateKeySystemInformation(findChildren(adaptationSet, 'ContentProtection'));\n\n    if (Object.keys(contentProtection).length) {\n      attrs = merge(attrs, {\n        contentProtection: contentProtection\n      });\n    }\n\n    var segmentInfo = getSegmentInformation(adaptationSet);\n    var representations = findChildren(adaptationSet, 'Representation');\n    var adaptationSetSegmentInfo = merge(periodSegmentInfo, segmentInfo);\n    return flatten(representations.map(inheritBaseUrls(attrs, adaptationSetBaseUrls, adaptationSetSegmentInfo)));\n  };\n};\n/**\n * Contains all period information for mapping nodes onto adaptation sets.\n *\n * @typedef {Object} PeriodInformation\n * @property {Node} period.node\n *           Period node from the mpd\n * @property {Object} period.attributes\n *           Parsed period attributes from node plus any added\n */\n\n/**\n * Maps a PeriodInformation object to a list of Representation information objects for all\n * AdaptationSet nodes contained within the Period.\n *\n * @name toAdaptationSetsCallback\n * @function\n * @param {PeriodInformation} period\n *        Period object containing necessary period information\n * @param {number} periodStart\n *        Start time of the Period within the mpd\n * @return {RepresentationInformation[]}\n *         List of objects containing Representaion information\n */\n\n/**\n * Returns a callback for Array.prototype.map for mapping Period nodes to a list of\n * Representation information objects\n *\n * @param {Object} mpdAttributes\n *        Contains attributes inherited by the mpd\n * @param {string[]} mpdBaseUrls\n *        Contains list of resolved base urls inherited by the mpd\n * @return {toAdaptationSetsCallback}\n *         Callback map function\n */\n\nvar toAdaptationSets = function toAdaptationSets(mpdAttributes, mpdBaseUrls) {\n  return function (period, index) {\n    var periodBaseUrls = buildBaseUrls(mpdBaseUrls, findChildren(period.node, 'BaseURL'));\n    var periodAttributes = merge(mpdAttributes, {\n      periodStart: period.attributes.start\n    });\n\n    if (typeof period.attributes.duration === 'number') {\n      periodAttributes.periodDuration = period.attributes.duration;\n    }\n\n    var adaptationSets = findChildren(period.node, 'AdaptationSet');\n    var periodSegmentInfo = getSegmentInformation(period.node);\n    return flatten(adaptationSets.map(toRepresentations(periodAttributes, periodBaseUrls, periodSegmentInfo)));\n  };\n};\n/**\n * Gets Period@start property for a given period.\n *\n * @param {Object} options\n *        Options object\n * @param {Object} options.attributes\n *        Period attributes\n * @param {Object} [options.priorPeriodAttributes]\n *        Prior period attributes (if prior period is available)\n * @param {string} options.mpdType\n *        The MPD@type these periods came from\n * @return {number|null}\n *         The period start, or null if it's an early available period or error\n */\n\nvar getPeriodStart = function getPeriodStart(_ref) {\n  var attributes = _ref.attributes,\n      priorPeriodAttributes = _ref.priorPeriodAttributes,\n      mpdType = _ref.mpdType;\n\n  // Summary of period start time calculation from DASH spec section 5.3.2.1\n  //\n  // A period's start is the first period's start + time elapsed after playing all\n  // prior periods to this one. Periods continue one after the other in time (without\n  // gaps) until the end of the presentation.\n  //\n  // The value of Period@start should be:\n  // 1. if Period@start is present: value of Period@start\n  // 2. if previous period exists and it has @duration: previous Period@start +\n  //    previous Period@duration\n  // 3. if this is first period and MPD@type is 'static': 0\n  // 4. in all other cases, consider the period an \"early available period\" (note: not\n  //    currently supported)\n  // (1)\n  if (typeof attributes.start === 'number') {\n    return attributes.start;\n  } // (2)\n\n\n  if (priorPeriodAttributes && typeof priorPeriodAttributes.start === 'number' && typeof priorPeriodAttributes.duration === 'number') {\n    return priorPeriodAttributes.start + priorPeriodAttributes.duration;\n  } // (3)\n\n\n  if (!priorPeriodAttributes && mpdType === 'static') {\n    return 0;\n  } // (4)\n  // There is currently no logic for calculating the Period@start value if there is\n  // no Period@start or prior Period@start and Period@duration available. This is not made\n  // explicit by the DASH interop guidelines or the DASH spec, however, since there's\n  // nothing about any other resolution strategies, it's implied. Thus, this case should\n  // be considered an early available period, or error, and null should suffice for both\n  // of those cases.\n\n\n  return null;\n};\n/**\n * Traverses the mpd xml tree to generate a list of Representation information objects\n * that have inherited attributes from parent nodes\n *\n * @param {Node} mpd\n *        The root node of the mpd\n * @param {Object} options\n *        Available options for inheritAttributes\n * @param {string} options.manifestUri\n *        The uri source of the mpd\n * @param {number} options.NOW\n *        Current time per DASH IOP.  Default is current time in ms since epoch\n * @param {number} options.clientOffset\n *        Client time difference from NOW (in milliseconds)\n * @return {RepresentationInformation[]}\n *         List of objects containing Representation information\n */\n\nvar inheritAttributes = function inheritAttributes(mpd, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var _options = options,\n      _options$manifestUri = _options.manifestUri,\n      manifestUri = _options$manifestUri === void 0 ? '' : _options$manifestUri,\n      _options$NOW = _options.NOW,\n      NOW = _options$NOW === void 0 ? Date.now() : _options$NOW,\n      _options$clientOffset = _options.clientOffset,\n      clientOffset = _options$clientOffset === void 0 ? 0 : _options$clientOffset;\n  var periodNodes = findChildren(mpd, 'Period');\n\n  if (!periodNodes.length) {\n    throw new Error(errors.INVALID_NUMBER_OF_PERIOD);\n  }\n\n  var locations = findChildren(mpd, 'Location');\n  var mpdAttributes = parseAttributes(mpd);\n  var mpdBaseUrls = buildBaseUrls([manifestUri], findChildren(mpd, 'BaseURL')); // See DASH spec section 5.3.1.2, Semantics of MPD element. Default type to 'static'.\n\n  mpdAttributes.type = mpdAttributes.type || 'static';\n  mpdAttributes.sourceDuration = mpdAttributes.mediaPresentationDuration || 0;\n  mpdAttributes.NOW = NOW;\n  mpdAttributes.clientOffset = clientOffset;\n\n  if (locations.length) {\n    mpdAttributes.locations = locations.map(getContent);\n  }\n\n  var periods = []; // Since toAdaptationSets acts on individual periods right now, the simplest approach to\n  // adding properties that require looking at prior periods is to parse attributes and add\n  // missing ones before toAdaptationSets is called. If more such properties are added, it\n  // may be better to refactor toAdaptationSets.\n\n  periodNodes.forEach(function (node, index) {\n    var attributes = parseAttributes(node); // Use the last modified prior period, as it may contain added information necessary\n    // for this period.\n\n    var priorPeriod = periods[index - 1];\n    attributes.start = getPeriodStart({\n      attributes: attributes,\n      priorPeriodAttributes: priorPeriod ? priorPeriod.attributes : null,\n      mpdType: mpdAttributes.type\n    });\n    periods.push({\n      node: node,\n      attributes: attributes\n    });\n  });\n  return {\n    locations: mpdAttributes.locations,\n    representationInfo: flatten(periods.map(toAdaptationSets(mpdAttributes, mpdBaseUrls)))\n  };\n};\n\nvar stringToMpdXml = function stringToMpdXml(manifestString) {\n  if (manifestString === '') {\n    throw new Error(errors.DASH_EMPTY_MANIFEST);\n  }\n\n  var parser = new DOMParser();\n  var xml;\n  var mpd;\n\n  try {\n    xml = parser.parseFromString(manifestString, 'application/xml');\n    mpd = xml && xml.documentElement.tagName === 'MPD' ? xml.documentElement : null;\n  } catch (e) {// ie 11 throwsw on invalid xml\n  }\n\n  if (!mpd || mpd && mpd.getElementsByTagName('parsererror').length > 0) {\n    throw new Error(errors.DASH_INVALID_XML);\n  }\n\n  return mpd;\n};\n\n/**\n * Parses the manifest for a UTCTiming node, returning the nodes attributes if found\n *\n * @param {string} mpd\n *        XML string of the MPD manifest\n * @return {Object|null}\n *         Attributes of UTCTiming node specified in the manifest. Null if none found\n */\n\nvar parseUTCTimingScheme = function parseUTCTimingScheme(mpd) {\n  var UTCTimingNode = findChildren(mpd, 'UTCTiming')[0];\n\n  if (!UTCTimingNode) {\n    return null;\n  }\n\n  var attributes = parseAttributes(UTCTimingNode);\n\n  switch (attributes.schemeIdUri) {\n    case 'urn:mpeg:dash:utc:http-head:2014':\n    case 'urn:mpeg:dash:utc:http-head:2012':\n      attributes.method = 'HEAD';\n      break;\n\n    case 'urn:mpeg:dash:utc:http-xsdate:2014':\n    case 'urn:mpeg:dash:utc:http-iso:2014':\n    case 'urn:mpeg:dash:utc:http-xsdate:2012':\n    case 'urn:mpeg:dash:utc:http-iso:2012':\n      attributes.method = 'GET';\n      break;\n\n    case 'urn:mpeg:dash:utc:direct:2014':\n    case 'urn:mpeg:dash:utc:direct:2012':\n      attributes.method = 'DIRECT';\n      attributes.value = Date.parse(attributes.value);\n      break;\n\n    case 'urn:mpeg:dash:utc:http-ntp:2014':\n    case 'urn:mpeg:dash:utc:ntp:2014':\n    case 'urn:mpeg:dash:utc:sntp:2014':\n    default:\n      throw new Error(errors.UNSUPPORTED_UTC_TIMING_SCHEME);\n  }\n\n  return attributes;\n};\n\nvar VERSION = version;\n/*\n * Given a DASH manifest string and options, parses the DASH manifest into an object in the\n * form outputed by m3u8-parser and accepted by videojs/http-streaming.\n *\n * For live DASH manifests, if `previousManifest` is provided in options, then the newly\n * parsed DASH manifest will have its media sequence and discontinuity sequence values\n * updated to reflect its position relative to the prior manifest.\n *\n * @param {string} manifestString - the DASH manifest as a string\n * @param {options} [options] - any options\n *\n * @return {Object} the manifest object\n */\n\nvar parse = function parse(manifestString, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var parsedManifestInfo = inheritAttributes(stringToMpdXml(manifestString), options);\n  var playlists = toPlaylists(parsedManifestInfo.representationInfo);\n  return toM3u8({\n    dashPlaylists: playlists,\n    locations: parsedManifestInfo.locations,\n    sidxMapping: options.sidxMapping,\n    previousManifest: options.previousManifest\n  });\n};\n/**\n * Parses the manifest for a UTCTiming node, returning the nodes attributes if found\n *\n * @param {string} manifestString\n *        XML string of the MPD manifest\n * @return {Object|null}\n *         Attributes of UTCTiming node specified in the manifest. Null if none found\n */\n\n\nvar parseUTCTiming = function parseUTCTiming(manifestString) {\n  return parseUTCTimingScheme(stringToMpdXml(manifestString));\n};\n\nexport { VERSION, addSidxSegmentsToPlaylist$1 as addSidxSegmentsToPlaylist, generateSidxKey, inheritAttributes, parse, parseUTCTiming, stringToMpdXml, toM3u8, toPlaylists };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}