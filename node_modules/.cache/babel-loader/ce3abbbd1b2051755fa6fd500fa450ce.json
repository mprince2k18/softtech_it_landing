{"ast":null,"code":"import { toUint8, bytesMatch } from './byte-helpers.js';\nimport { findBox } from './mp4-helpers.js';\nimport { findEbml, EBML_TAGS } from './ebml-helpers.js';\nimport { getId3Offset } from './id3-helpers.js';\nimport { findH264Nal, findH265Nal } from './nal-helpers.js';\nvar CONSTANTS = {\n  // \"webm\" string literal in hex\n  'webm': toUint8([0x77, 0x65, 0x62, 0x6d]),\n  // \"matroska\" string literal in hex\n  'matroska': toUint8([0x6d, 0x61, 0x74, 0x72, 0x6f, 0x73, 0x6b, 0x61]),\n  // \"fLaC\" string literal in hex\n  'flac': toUint8([0x66, 0x4c, 0x61, 0x43]),\n  // \"OggS\" string literal in hex\n  'ogg': toUint8([0x4f, 0x67, 0x67, 0x53]),\n  // ac-3 sync byte, also works for ec-3 as that is simply a codec\n  // of ac-3\n  'ac3': toUint8([0x0b, 0x77]),\n  // \"RIFF\" string literal in hex used for wav and avi\n  'riff': toUint8([0x52, 0x49, 0x46, 0x46]),\n  // \"AVI\" string literal in hex\n  'avi': toUint8([0x41, 0x56, 0x49]),\n  // \"WAVE\" string literal in hex\n  'wav': toUint8([0x57, 0x41, 0x56, 0x45]),\n  // \"ftyp3g\" string literal in hex\n  '3gp': toUint8([0x66, 0x74, 0x79, 0x70, 0x33, 0x67]),\n  // \"ftyp\" string literal in hex\n  'mp4': toUint8([0x66, 0x74, 0x79, 0x70]),\n  // \"styp\" string literal in hex\n  'fmp4': toUint8([0x73, 0x74, 0x79, 0x70]),\n  // \"ftypqt\" string literal in hex\n  'mov': toUint8([0x66, 0x74, 0x79, 0x70, 0x71, 0x74]),\n  // moov string literal in hex\n  'moov': toUint8([0x6D, 0x6F, 0x6F, 0x76]),\n  // moof string literal in hex\n  'moof': toUint8([0x6D, 0x6F, 0x6F, 0x66])\n};\nvar _isLikely = {\n  aac: function aac(bytes) {\n    var offset = getId3Offset(bytes);\n    return bytesMatch(bytes, [0xFF, 0x10], {\n      offset: offset,\n      mask: [0xFF, 0x16]\n    });\n  },\n  mp3: function mp3(bytes) {\n    var offset = getId3Offset(bytes);\n    return bytesMatch(bytes, [0xFF, 0x02], {\n      offset: offset,\n      mask: [0xFF, 0x06]\n    });\n  },\n  webm: function webm(bytes) {\n    var docType = findEbml(bytes, [EBML_TAGS.EBML, EBML_TAGS.DocType])[0]; // check if DocType EBML tag is webm\n\n    return bytesMatch(docType, CONSTANTS.webm);\n  },\n  mkv: function mkv(bytes) {\n    var docType = findEbml(bytes, [EBML_TAGS.EBML, EBML_TAGS.DocType])[0]; // check if DocType EBML tag is matroska\n\n    return bytesMatch(docType, CONSTANTS.matroska);\n  },\n  mp4: function mp4(bytes) {\n    // if this file is another base media file format, it is not mp4\n    if (_isLikely['3gp'](bytes) || _isLikely.mov(bytes)) {\n      return false;\n    } // if this file starts with a ftyp or styp box its mp4\n\n\n    if (bytesMatch(bytes, CONSTANTS.mp4, {\n      offset: 4\n    }) || bytesMatch(bytes, CONSTANTS.fmp4, {\n      offset: 4\n    })) {\n      return true;\n    } // if this file starts with a moof/moov box its mp4\n\n\n    if (bytesMatch(bytes, CONSTANTS.moof, {\n      offset: 4\n    }) || bytesMatch(bytes, CONSTANTS.moov, {\n      offset: 4\n    })) {\n      return true;\n    }\n  },\n  mov: function mov(bytes) {\n    return bytesMatch(bytes, CONSTANTS.mov, {\n      offset: 4\n    });\n  },\n  '3gp': function gp(bytes) {\n    return bytesMatch(bytes, CONSTANTS['3gp'], {\n      offset: 4\n    });\n  },\n  ac3: function ac3(bytes) {\n    var offset = getId3Offset(bytes);\n    return bytesMatch(bytes, CONSTANTS.ac3, {\n      offset: offset\n    });\n  },\n  ts: function ts(bytes) {\n    if (bytes.length < 189 && bytes.length >= 1) {\n      return bytes[0] === 0x47;\n    }\n\n    var i = 0; // check the first 376 bytes for two matching sync bytes\n\n    while (i + 188 < bytes.length && i < 188) {\n      if (bytes[i] === 0x47 && bytes[i + 188] === 0x47) {\n        return true;\n      }\n\n      i += 1;\n    }\n\n    return false;\n  },\n  flac: function flac(bytes) {\n    var offset = getId3Offset(bytes);\n    return bytesMatch(bytes, CONSTANTS.flac, {\n      offset: offset\n    });\n  },\n  ogg: function ogg(bytes) {\n    return bytesMatch(bytes, CONSTANTS.ogg);\n  },\n  avi: function avi(bytes) {\n    return bytesMatch(bytes, CONSTANTS.riff) && bytesMatch(bytes, CONSTANTS.avi, {\n      offset: 8\n    });\n  },\n  wav: function wav(bytes) {\n    return bytesMatch(bytes, CONSTANTS.riff) && bytesMatch(bytes, CONSTANTS.wav, {\n      offset: 8\n    });\n  },\n  'h264': function h264(bytes) {\n    // find seq_parameter_set_rbsp\n    return findH264Nal(bytes, 7, 3).length;\n  },\n  'h265': function h265(bytes) {\n    // find video_parameter_set_rbsp or seq_parameter_set_rbsp\n    return findH265Nal(bytes, [32, 33], 3).length;\n  }\n}; // get all the isLikely functions\n// but make sure 'ts' is above h264 and h265\n// but below everything else as it is the least specific\n\nvar isLikelyTypes = Object.keys(_isLikely) // remove ts, h264, h265\n.filter(function (t) {\n  return t !== 'ts' && t !== 'h264' && t !== 'h265';\n}) // add it back to the bottom\n.concat(['ts', 'h264', 'h265']); // make sure we are dealing with uint8 data.\n\nisLikelyTypes.forEach(function (type) {\n  var isLikelyFn = _isLikely[type];\n\n  _isLikely[type] = function (bytes) {\n    return isLikelyFn(toUint8(bytes));\n  };\n}); // export after wrapping\n\nexport var isLikely = _isLikely; // A useful list of file signatures can be found here\n// https://en.wikipedia.org/wiki/List_of_file_signatures\n\nexport var detectContainerForBytes = function detectContainerForBytes(bytes) {\n  bytes = toUint8(bytes);\n\n  for (var i = 0; i < isLikelyTypes.length; i++) {\n    var type = isLikelyTypes[i];\n\n    if (isLikely[type](bytes)) {\n      return type;\n    }\n  }\n\n  return '';\n}; // fmp4 is not a container\n\nexport var isLikelyFmp4MediaSegment = function isLikelyFmp4MediaSegment(bytes) {\n  return findBox(bytes, ['moof']).length > 0;\n};","map":{"version":3,"names":["toUint8","bytesMatch","findBox","findEbml","EBML_TAGS","getId3Offset","findH264Nal","findH265Nal","CONSTANTS","_isLikely","aac","bytes","offset","mask","mp3","webm","docType","EBML","DocType","mkv","matroska","mp4","mov","fmp4","moof","moov","gp","ac3","ts","length","i","flac","ogg","avi","riff","wav","h264","h265","isLikelyTypes","Object","keys","filter","t","concat","forEach","type","isLikelyFn","isLikely","detectContainerForBytes","isLikelyFmp4MediaSegment"],"sources":["C:/office/xampp/htdocs/softtech_it_landing/node_modules/@videojs/vhs-utils/es/containers.js"],"sourcesContent":["import { toUint8, bytesMatch } from './byte-helpers.js';\nimport { findBox } from './mp4-helpers.js';\nimport { findEbml, EBML_TAGS } from './ebml-helpers.js';\nimport { getId3Offset } from './id3-helpers.js';\nimport { findH264Nal, findH265Nal } from './nal-helpers.js';\nvar CONSTANTS = {\n  // \"webm\" string literal in hex\n  'webm': toUint8([0x77, 0x65, 0x62, 0x6d]),\n  // \"matroska\" string literal in hex\n  'matroska': toUint8([0x6d, 0x61, 0x74, 0x72, 0x6f, 0x73, 0x6b, 0x61]),\n  // \"fLaC\" string literal in hex\n  'flac': toUint8([0x66, 0x4c, 0x61, 0x43]),\n  // \"OggS\" string literal in hex\n  'ogg': toUint8([0x4f, 0x67, 0x67, 0x53]),\n  // ac-3 sync byte, also works for ec-3 as that is simply a codec\n  // of ac-3\n  'ac3': toUint8([0x0b, 0x77]),\n  // \"RIFF\" string literal in hex used for wav and avi\n  'riff': toUint8([0x52, 0x49, 0x46, 0x46]),\n  // \"AVI\" string literal in hex\n  'avi': toUint8([0x41, 0x56, 0x49]),\n  // \"WAVE\" string literal in hex\n  'wav': toUint8([0x57, 0x41, 0x56, 0x45]),\n  // \"ftyp3g\" string literal in hex\n  '3gp': toUint8([0x66, 0x74, 0x79, 0x70, 0x33, 0x67]),\n  // \"ftyp\" string literal in hex\n  'mp4': toUint8([0x66, 0x74, 0x79, 0x70]),\n  // \"styp\" string literal in hex\n  'fmp4': toUint8([0x73, 0x74, 0x79, 0x70]),\n  // \"ftypqt\" string literal in hex\n  'mov': toUint8([0x66, 0x74, 0x79, 0x70, 0x71, 0x74]),\n  // moov string literal in hex\n  'moov': toUint8([0x6D, 0x6F, 0x6F, 0x76]),\n  // moof string literal in hex\n  'moof': toUint8([0x6D, 0x6F, 0x6F, 0x66])\n};\nvar _isLikely = {\n  aac: function aac(bytes) {\n    var offset = getId3Offset(bytes);\n    return bytesMatch(bytes, [0xFF, 0x10], {\n      offset: offset,\n      mask: [0xFF, 0x16]\n    });\n  },\n  mp3: function mp3(bytes) {\n    var offset = getId3Offset(bytes);\n    return bytesMatch(bytes, [0xFF, 0x02], {\n      offset: offset,\n      mask: [0xFF, 0x06]\n    });\n  },\n  webm: function webm(bytes) {\n    var docType = findEbml(bytes, [EBML_TAGS.EBML, EBML_TAGS.DocType])[0]; // check if DocType EBML tag is webm\n\n    return bytesMatch(docType, CONSTANTS.webm);\n  },\n  mkv: function mkv(bytes) {\n    var docType = findEbml(bytes, [EBML_TAGS.EBML, EBML_TAGS.DocType])[0]; // check if DocType EBML tag is matroska\n\n    return bytesMatch(docType, CONSTANTS.matroska);\n  },\n  mp4: function mp4(bytes) {\n    // if this file is another base media file format, it is not mp4\n    if (_isLikely['3gp'](bytes) || _isLikely.mov(bytes)) {\n      return false;\n    } // if this file starts with a ftyp or styp box its mp4\n\n\n    if (bytesMatch(bytes, CONSTANTS.mp4, {\n      offset: 4\n    }) || bytesMatch(bytes, CONSTANTS.fmp4, {\n      offset: 4\n    })) {\n      return true;\n    } // if this file starts with a moof/moov box its mp4\n\n\n    if (bytesMatch(bytes, CONSTANTS.moof, {\n      offset: 4\n    }) || bytesMatch(bytes, CONSTANTS.moov, {\n      offset: 4\n    })) {\n      return true;\n    }\n  },\n  mov: function mov(bytes) {\n    return bytesMatch(bytes, CONSTANTS.mov, {\n      offset: 4\n    });\n  },\n  '3gp': function gp(bytes) {\n    return bytesMatch(bytes, CONSTANTS['3gp'], {\n      offset: 4\n    });\n  },\n  ac3: function ac3(bytes) {\n    var offset = getId3Offset(bytes);\n    return bytesMatch(bytes, CONSTANTS.ac3, {\n      offset: offset\n    });\n  },\n  ts: function ts(bytes) {\n    if (bytes.length < 189 && bytes.length >= 1) {\n      return bytes[0] === 0x47;\n    }\n\n    var i = 0; // check the first 376 bytes for two matching sync bytes\n\n    while (i + 188 < bytes.length && i < 188) {\n      if (bytes[i] === 0x47 && bytes[i + 188] === 0x47) {\n        return true;\n      }\n\n      i += 1;\n    }\n\n    return false;\n  },\n  flac: function flac(bytes) {\n    var offset = getId3Offset(bytes);\n    return bytesMatch(bytes, CONSTANTS.flac, {\n      offset: offset\n    });\n  },\n  ogg: function ogg(bytes) {\n    return bytesMatch(bytes, CONSTANTS.ogg);\n  },\n  avi: function avi(bytes) {\n    return bytesMatch(bytes, CONSTANTS.riff) && bytesMatch(bytes, CONSTANTS.avi, {\n      offset: 8\n    });\n  },\n  wav: function wav(bytes) {\n    return bytesMatch(bytes, CONSTANTS.riff) && bytesMatch(bytes, CONSTANTS.wav, {\n      offset: 8\n    });\n  },\n  'h264': function h264(bytes) {\n    // find seq_parameter_set_rbsp\n    return findH264Nal(bytes, 7, 3).length;\n  },\n  'h265': function h265(bytes) {\n    // find video_parameter_set_rbsp or seq_parameter_set_rbsp\n    return findH265Nal(bytes, [32, 33], 3).length;\n  }\n}; // get all the isLikely functions\n// but make sure 'ts' is above h264 and h265\n// but below everything else as it is the least specific\n\nvar isLikelyTypes = Object.keys(_isLikely) // remove ts, h264, h265\n.filter(function (t) {\n  return t !== 'ts' && t !== 'h264' && t !== 'h265';\n}) // add it back to the bottom\n.concat(['ts', 'h264', 'h265']); // make sure we are dealing with uint8 data.\n\nisLikelyTypes.forEach(function (type) {\n  var isLikelyFn = _isLikely[type];\n\n  _isLikely[type] = function (bytes) {\n    return isLikelyFn(toUint8(bytes));\n  };\n}); // export after wrapping\n\nexport var isLikely = _isLikely; // A useful list of file signatures can be found here\n// https://en.wikipedia.org/wiki/List_of_file_signatures\n\nexport var detectContainerForBytes = function detectContainerForBytes(bytes) {\n  bytes = toUint8(bytes);\n\n  for (var i = 0; i < isLikelyTypes.length; i++) {\n    var type = isLikelyTypes[i];\n\n    if (isLikely[type](bytes)) {\n      return type;\n    }\n  }\n\n  return '';\n}; // fmp4 is not a container\n\nexport var isLikelyFmp4MediaSegment = function isLikelyFmp4MediaSegment(bytes) {\n  return findBox(bytes, ['moof']).length > 0;\n};"],"mappings":"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"},"metadata":{},"sourceType":"module"}